
/private/var/folders/vf/1fkkm63x40vcn1pgl1stdsdc0000gn/T/arduino/sketches/BC9DBD67FFE292254BF81316C398885B/sd-firmware-v2_1.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../../crt1/gcrt1.S:63
   0:	28 c0       	rjmp	.+80     	; 0x52 <__ctors_end>
../../../../../crt1/gcrt1.S:67
   2:	4e c0       	rjmp	.+156    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:68
   4:	4d c0       	rjmp	.+154    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:69
   6:	64 c1       	rjmp	.+712    	; 0x2d0 <__vector_3>
../../../../../crt1/gcrt1.S:70
   8:	4b c0       	rjmp	.+150    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:71
   a:	4a c0       	rjmp	.+148    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:72
   c:	49 c0       	rjmp	.+146    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:73
   e:	48 c0       	rjmp	.+144    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:74
  10:	47 c0       	rjmp	.+142    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:75
  12:	c8 c0       	rjmp	.+400    	; 0x1a4 <__vector_9>
../../../../../crt1/gcrt1.S:76
  14:	45 c0       	rjmp	.+138    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:77
  16:	44 c0       	rjmp	.+136    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:78
  18:	43 c0       	rjmp	.+134    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:79
  1a:	f5 c0       	rjmp	.+490    	; 0x206 <__vector_13>
../../../../../crt1/gcrt1.S:80
  1c:	41 c0       	rjmp	.+130    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:81
  1e:	40 c0       	rjmp	.+128    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:82
  20:	3f c0       	rjmp	.+126    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:83
  22:	3e c0       	rjmp	.+124    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:84
  24:	3d c0       	rjmp	.+122    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:85
  26:	3c c0       	rjmp	.+120    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:86
  28:	3b c0       	rjmp	.+118    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:87
  2a:	3a c0       	rjmp	.+116    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:88
  2c:	39 c0       	rjmp	.+114    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:89
  2e:	38 c0       	rjmp	.+112    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:90
  30:	37 c0       	rjmp	.+110    	; 0xa0 <__bad_interrupt>
../../../../../crt1/gcrt1.S:91
  32:	36 c0       	rjmp	.+108    	; 0xa0 <__bad_interrupt>
  34:	05 a8       	ldd	r0, Z+53	; 0x35
  36:	4c cd       	rjmp	.-1384   	; 0xfffffad0 <__eeprom_end+0xff7efad0>
  38:	b2 d4       	rcall	.+2404   	; 0x99e <__fp_sinus+0x20>
  3a:	4e b9       	out	0x0e, r20	; 14
  3c:	38 36       	cpi	r19, 0x68	; 104
  3e:	a9 02       	muls	r26, r25
  40:	0c 50       	subi	r16, 0x0C	; 12
  42:	b9 91       	ld	r27, Y+
  44:	86 88       	ldd	r8, Z+22	; 0x16
  46:	08 3c       	cpi	r16, 0xC8	; 200
  48:	a6 aa       	std	Z+54, r10	; 0x36
  4a:	aa 2a       	or	r10, r26
  4c:	be 00       	.word	0x00be	; ????
  4e:	00 00       	nop
  50:	80 3f       	cpi	r24, 0xF0	; 240

00000052 <__ctors_end>:
__trampolines_start():
../../../../../crt1/gcrt1.S:230
  52:	11 24       	eor	r1, r1
../../../../../crt1/gcrt1.S:231
  54:	1f be       	out	0x3f, r1	; 63
../../../../../crt1/gcrt1.S:232
  56:	cf ef       	ldi	r28, 0xFF	; 255
../../../../../crt1/gcrt1.S:234
  58:	cd bf       	out	0x3d, r28	; 61
../../../../../crt1/gcrt1.S:236
  5a:	df e3       	ldi	r29, 0x3F	; 63
../../../../../crt1/gcrt1.S:237
  5c:	de bf       	out	0x3e, r29	; 62

0000005e <_initThreeStuff()>:
_Z15_initThreeStuffv():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:104

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
  5e:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <digital_pin_to_bit_mask+0x7f74aa>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:105
    RSTCTRL.RSTFR = flags;
  62:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <digital_pin_to_bit_mask+0x7f74aa>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:106
    if (flags == 0) {
  66:	81 11       	cpse	r24, r1
  68:	05 c0       	rjmp	.+10     	; 0x74 <_initThreeStuff()+0x16>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:107
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
  6a:	98 ed       	ldi	r25, 0xD8	; 216
  6c:	21 e0       	ldi	r18, 0x01	; 1
  6e:	94 bf       	out	0x34, r25	; 52
  70:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <digital_pin_to_bit_mask+0x7f74ab>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:109
    }
    GPIOR0 = flags;
  74:	8c bb       	out	0x1c, r24	; 28

00000076 <__do_copy_data>:
__do_copy_data():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  76:	1f e3       	ldi	r17, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  78:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  7a:	bf e3       	ldi	r27, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  7c:	ec e9       	ldi	r30, 0x9C	; 156
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  7e:	fb e0       	ldi	r31, 0x0B	; 11
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  80:	02 c0       	rjmp	.+4      	; 0x86 <__EEPROM_REGION_LENGTH__+0x6>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  82:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  84:	0d 92       	st	X+, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  86:	a2 30       	cpi	r26, 0x02	; 2
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  88:	b1 07       	cpc	r27, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  8a:	d9 f7       	brne	.-10     	; 0x82 <__EEPROM_REGION_LENGTH__+0x2>

0000008c <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  8c:	2f e3       	ldi	r18, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  8e:	a2 e0       	ldi	r26, 0x02	; 2
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  90:	bf e3       	ldi	r27, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  92:	01 c0       	rjmp	.+2      	; 0x96 <.do_clear_bss_start>

00000094 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  96:	aa 32       	cpi	r26, 0x2A	; 42
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  98:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  9a:	e1 f7       	brne	.-8      	; 0x94 <.do_clear_bss_loop>
.do_clear_bss_start():
../../../../../crt1/gcrt1.S:314
  9c:	2b d1       	rcall	.+598    	; 0x2f4 <main>
../../../../../crt1/gcrt1.S:315
  9e:	70 c5       	rjmp	.+2784   	; 0xb80 <_exit>

000000a0 <__bad_interrupt>:
__vector_22():
../../../../../crt1/gcrt1.S:209
  a0:	af cf       	rjmp	.-162    	; 0x0 <__vectors>

000000a2 <millis>:
millis():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:441
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
  a2:	2f b7       	in	r18, 0x3f	; 63
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:442
    cli();
  a4:	f8 94       	cli
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:493
        "adc %D0, %D1"    "\n\t"
        : "+r" (m), "+r" (temp), "+d" (cnt)
        );
      */
    #else
      m = timingStruct.timer_millis;
  a6:	60 91 24 3f 	lds	r22, 0x3F24	; 0x803f24 <timingStruct+0x4>
  aa:	70 91 25 3f 	lds	r23, 0x3F25	; 0x803f25 <timingStruct+0x5>
  ae:	80 91 26 3f 	lds	r24, 0x3F26	; 0x803f26 <timingStruct+0x6>
  b2:	90 91 27 3f 	lds	r25, 0x3F27	; 0x803f27 <timingStruct+0x7>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:494
      SREG = oldSREG;
  b6:	2f bf       	out	0x3f, r18	; 63
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:497
    #endif
    return m;
  }
  b8:	08 95       	ret

000000ba <disableTimer()>:
_ZL12disableTimerv():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:294
#ifndef TONE_UNAVAILABLE
  // helper functiodn for ending tone.
  /* Works for all timers -- the timer being disabled will go back to the
      configuration it had on startup */
  static void disableTimer() {
    _timer->CTRLA     = 0; // disable timer
  ba:	e0 e4       	ldi	r30, 0x40	; 64
  bc:	fa e0       	ldi	r31, 0x0A	; 10
  be:	10 82       	st	Z, r1
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:295
    _timer->INTCTRL   = 0; // disable the timer interrupts, otherwise if something else configures it and assumes that it's in the reset configuration
  c0:	15 82       	std	Z+5, r1	; 0x05
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:297
    // and so doesn't write INTCTRL (because it doesn't use interrupts), the tone ISR could be called inappropriately.
    _timer->INTFLAGS  = 0xFF; // Make sure the flags are cleared (flags can be set without their interrupt being enabled, these will fire as soon as it is)
  c2:	8f ef       	ldi	r24, 0xFF	; 255
  c4:	86 83       	std	Z+6, r24	; 0x06
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:298
    _pin              = NOT_A_PIN; // and clear _pin.
  c6:	80 93 00 3f 	sts	0x3F00, r24	; 0x803f00 <__DATA_REGION_ORIGIN__>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:308
      _timer->CTRLB = (TCB_CNTMODE_PWM8_gc); // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      _timer->CCMPL = PWM_TIMER_PERIOD;      // Assign 8-bit period, probably 254.
      _timer->CCMPH = PWM_TIMER_COMPARE;     // We need to set low byte in order for high byte to be written (see silicon errata).
      _timer->CTRLA = (TCB_CLKSEL_CLKTCA_gc) | (TCB_ENABLE_bm); // Use TCA clock (250kHz) and enable
    #endif
    *(timer_outtgl_reg - 1) = timer_bit_mask; // Write OUTCLR, so we are sure to end with pin LOW.
  ca:	e0 91 09 3f 	lds	r30, 0x3F09	; 0x803f09 <timer_outtgl_reg>
  ce:	f0 91 0a 3f 	lds	r31, 0x3F0A	; 0x803f0a <timer_outtgl_reg+0x1>
  d2:	80 91 08 3f 	lds	r24, 0x3F08	; 0x803f08 <timer_bit_mask>
  d6:	31 97       	sbiw	r30, 0x01	; 1
  d8:	80 83       	st	Z, r24
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:309
  }
  da:	08 95       	ret

000000dc <noTone(unsigned char) [clone .part.0]>:
_Z6noToneh.part.0():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:273
  }
#endif

// pin which currently is being used for a tone
#ifndef TONE_UNAVAILABLE
  void noTone(uint8_t pin) {
  dc:	cf 93       	push	r28
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:275
    if (pin == _pin) {
      uint8_t old_SREG = SREG;  // Save SREG
  de:	cf b7       	in	r28, 0x3f	; 63
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:276
      cli();                    // Interrupts off
  e0:	f8 94       	cli
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:277
      timer_toggle_count = 0;   // clear this one
  e2:	10 92 04 3f 	sts	0x3F04, r1	; 0x803f04 <timer_toggle_count>
  e6:	10 92 05 3f 	sts	0x3F05, r1	; 0x803f05 <timer_toggle_count+0x1>
  ea:	10 92 06 3f 	sts	0x3F06, r1	; 0x803f06 <timer_toggle_count+0x2>
  ee:	10 92 07 3f 	sts	0x3F07, r1	; 0x803f07 <timer_toggle_count+0x3>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:278
      _pin = NOT_A_PIN;
  f2:	8f ef       	ldi	r24, 0xFF	; 255
  f4:	80 93 00 3f 	sts	0x3F00, r24	; 0x803f00 <__DATA_REGION_ORIGIN__>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:279
      disableTimer(); // End with pin LOW, otherwise can damage some speakers.
  f8:	e0 df       	rcall	.-64     	; 0xba <disableTimer()>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:280
      SREG = old_SREG;
  fa:	cf bf       	out	0x3f, r28	; 63
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:282
    }
  }
  fc:	cf 91       	pop	r28
  fe:	08 95       	ret

00000100 <digitalRead.constprop.0>:
digitalRead.constprop.0():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:371

  /* Get port and check valid port */
  PORT_t *port = digitalPinToPortStruct(pin);

  /* Read pin value from PORTx.IN register */
  if (port->IN & bit_mask) {
 100:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <digital_pin_to_bit_mask+0x7f7872>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:376
    return HIGH;
  } else {
    return LOW;
  }
}
 104:	82 fb       	bst	r24, 2
 106:	88 27       	eor	r24, r24
 108:	80 f9       	bld	r24, 0
 10a:	08 95       	ret

0000010c <digitalWrite>:
digitalWrite():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:240
    default:
      break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
 10c:	cf 93       	push	r28
 10e:	df 93       	push	r29
check_valid_digital_pin():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Arduino.h:873
#if !defined(NUM_TOTAL_PINS)
  #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
#endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
 110:	28 2f       	mov	r18, r24
 112:	30 e0       	ldi	r19, 0x00	; 0
digitalWrite():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:243
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
 114:	d9 01       	movw	r26, r18
 116:	aa 56       	subi	r26, 0x6A	; 106
 118:	b4 47       	sbci	r27, 0x74	; 116
 11a:	8c 91       	ld	r24, X
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:244
  if (bit_mask == NOT_A_PIN) {
 11c:	8f 3f       	cpi	r24, 0xFF	; 255
 11e:	b1 f1       	breq	.+108    	; 0x18c <digitalWrite+0x80>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:249
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
 120:	f9 01       	movw	r30, r18
 122:	e0 57       	subi	r30, 0x70	; 112
 124:	f4 47       	sbci	r31, 0x74	; 116
 126:	e0 81       	ld	r30, Z
 128:	90 e2       	ldi	r25, 0x20	; 32
 12a:	e9 9f       	mul	r30, r25
 12c:	f0 01       	movw	r30, r0
 12e:	11 24       	eor	r1, r1
 130:	fc 5f       	subi	r31, 0xFC	; 252
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:257
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
 132:	61 11       	cpse	r22, r1
 134:	2e c0       	rjmp	.+92     	; 0x192 <digitalWrite+0x86>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:258
    port->OUTCLR = bit_mask;
 136:	86 83       	std	Z+6, r24	; 0x06
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:282
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
 138:	90 81       	ld	r25, Z
 13a:	89 23       	and	r24, r25
 13c:	99 f4       	brne	.+38     	; 0x164 <digitalWrite+0x58>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:289
      pull up is enabled if this function is called.
      Should we purposely implement this side effect?
    */

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
 13e:	e9 01       	movw	r28, r18
 140:	c6 57       	subi	r28, 0x76	; 118
 142:	d4 47       	sbci	r29, 0x74	; 116
 144:	98 81       	ld	r25, Y
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:292

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
 146:	30 97       	sbiw	r30, 0x00	; 0
 148:	31 f1       	breq	.+76     	; 0x196 <digitalWrite+0x8a>
 14a:	98 30       	cpi	r25, 0x08	; 8
 14c:	20 f5       	brcc	.+72     	; 0x196 <digitalWrite+0x8a>
 14e:	70 96       	adiw	r30, 0x10	; 16
 150:	e9 0f       	add	r30, r25
 152:	f1 1d       	adc	r31, r1
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:295

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
 154:	9f b7       	in	r25, 0x3f	; 63
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:296
    cli();
 156:	f8 94       	cli
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:300

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 158:	80 81       	ld	r24, Z
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:298

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
 15a:	61 11       	cpse	r22, r1
 15c:	1f c0       	rjmp	.+62     	; 0x19c <digitalWrite+0x90>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:300
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 15e:	87 7f       	andi	r24, 0xF7	; 247
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:303
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 160:	80 83       	st	Z, r24
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:307
    }

    /* Restore system status */
    SREG = status;
 162:	9f bf       	out	0x3f, r25	; 63
turnOffPWM():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:107
   * any timers with minimum overhead - critical on these parts
   * Since nothing that will show up here can have more than one
   * one bit set, binary and will give 0x00 if that bit is cleared
   * which is NOT_ON_TIMER.
   */
  uint8_t digital_pin_timer =  digitalPinToTimer(pin) & __PeripheralControl;
 164:	2c 57       	subi	r18, 0x7C	; 124
 166:	34 47       	sbci	r19, 0x74	; 116
 168:	f9 01       	movw	r30, r18
 16a:	80 81       	ld	r24, Z
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:109
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
 16c:	88 23       	and	r24, r24
 16e:	71 f0       	breq	.+28     	; 0x18c <digitalWrite+0x80>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:116
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
  // TCB_t *timerB;

  switch (digital_pin_timer) {
 170:	80 31       	cpi	r24, 0x10	; 16
 172:	61 f4       	brne	.+24     	; 0x18c <digitalWrite+0x80>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:113
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
    return;
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
 174:	8c 91       	ld	r24, X
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:125
    {
      #if !defined(TCA_BUFFERED_3PIN)
        // uint8_t *timer_cmp_out;
        /* Bit position will give output channel */
        #ifdef __AVR_ATtinyxy2__
          if (bit_mask == 0x80) {
 176:	80 38       	cpi	r24, 0x80	; 128
 178:	99 f0       	breq	.+38     	; 0x1a0 <digitalWrite+0x94>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:128
            bit_mask = 1;         // on the xy2, WO0 is on PA7
          }
          if (bit_mask > 0x04) {  // -> bit_pos > 2 -> output channel controlled by HCMP
 17a:	85 30       	cpi	r24, 0x05	; 5
 17c:	08 f0       	brcs	.+2      	; 0x180 <digitalWrite+0x74>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:129
            bit_mask <<= 1;       // mind the gap (between LCMP and HCMP)
 17e:	88 0f       	add	r24, r24
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:142
          } else {
            // Otherwise, it's WO3-5. These will always be on 0b00hhh000,. Here since we ARE working with a high half timer, we need to just leftshift it once.
            bit_mask <<= 1;
          }
        #endif
        TCA0.SPLIT.CTRLB &= ~bit_mask;
 180:	90 91 01 0a 	lds	r25, 0x0A01	; 0x800a01 <digital_pin_to_bit_mask+0x7f7e6b>
 184:	80 95       	com	r24
 186:	89 23       	and	r24, r25
 188:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <digital_pin_to_bit_mask+0x7f7e6b>
digitalWrite():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:320
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
 18c:	df 91       	pop	r29
 18e:	cf 91       	pop	r28
 190:	08 95       	ret
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:278
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
 192:	85 83       	std	Z+5, r24	; 0x05
 194:	d1 cf       	rjmp	.-94     	; 0x138 <digitalWrite+0x2c>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:292

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
 196:	f0 e0       	ldi	r31, 0x00	; 0
 198:	e0 e0       	ldi	r30, 0x00	; 0
 19a:	dc cf       	rjmp	.-72     	; 0x154 <digitalWrite+0x48>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:303
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 19c:	88 60       	ori	r24, 0x08	; 8
 19e:	e0 cf       	rjmp	.-64     	; 0x160 <digitalWrite+0x54>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:126
      #if !defined(TCA_BUFFERED_3PIN)
        // uint8_t *timer_cmp_out;
        /* Bit position will give output channel */
        #ifdef __AVR_ATtinyxy2__
          if (bit_mask == 0x80) {
            bit_mask = 1;         // on the xy2, WO0 is on PA7
 1a0:	81 e0       	ldi	r24, 0x01	; 1
 1a2:	ee cf       	rjmp	.-36     	; 0x180 <digitalWrite+0x74>

000001a4 <__vector_9>:
__vector_9():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:206
  #else
    ISR(MILLIS_TIMER_VECTOR, ISR_NAKED) {
      // Common Interrupt header for TCB, TCA and TCD;
      // Clears the Timer Interrupt flag and pushes the CPU Registers
      // 7 words / 7 clocks
      __asm__ __volatile__(
 1a4:	8f 93       	push	r24
 1a6:	82 e0       	ldi	r24, 0x02	; 2
 1a8:	80 93 0b 0a 	sts	0x0A0B, r24	; 0x800a0b <digital_pin_to_bit_mask+0x7f7e75>
 1ac:	8f b7       	in	r24, 0x3f	; 63
 1ae:	8f 93       	push	r24
 1b0:	ef 93       	push	r30
 1b2:	ff 93       	push	r31
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:317
        [MIINC]  "M" ((0x0000 - MILLIS_INC) & 0xFF),
        [MINCD]  "M" ((0xFFFF - MILLIS_INC) & 0xFF)
      );
  */

      __asm__ __volatile__(
 1b4:	e0 e2       	ldi	r30, 0x20	; 32
 1b6:	ff e3       	ldi	r31, 0x3F	; 63
 1b8:	9f 93       	push	r25
 1ba:	68 94       	set
 1bc:	8f ef       	ldi	r24, 0xFF	; 255
 1be:	0f c0       	rjmp	.+30     	; 0x1de <sub4>

000001c0 <ovf_end>:
 1c0:	e8 94       	clt
 1c2:	84 81       	ldd	r24, Z+4	; 0x04
 1c4:	95 81       	ldd	r25, Z+5	; 0x05
 1c6:	88 58       	subi	r24, 0x88	; 136
 1c8:	9d 4f       	sbci	r25, 0xFD	; 253
 1ca:	84 83       	std	Z+4, r24	; 0x04
 1cc:	95 83       	std	Z+5, r25	; 0x05
 1ce:	88 5e       	subi	r24, 0xE8	; 232
 1d0:	93 40       	sbci	r25, 0x03	; 3
 1d2:	10 f0       	brcs	.+4      	; 0x1d8 <higher>
 1d4:	8f ef       	ldi	r24, 0xFF	; 255
 1d6:	03 c0       	rjmp	.+6      	; 0x1de <sub4>

000001d8 <higher>:
 1d8:	84 83       	std	Z+4, r24	; 0x04
 1da:	95 83       	std	Z+5, r25	; 0x05
 1dc:	8e ef       	ldi	r24, 0xFE	; 254

000001de <sub4>:
 1de:	90 81       	ld	r25, Z
 1e0:	98 1b       	sub	r25, r24
 1e2:	91 93       	st	Z+, r25
 1e4:	90 81       	ld	r25, Z
 1e6:	9f 4f       	sbci	r25, 0xFF	; 255
 1e8:	91 93       	st	Z+, r25
 1ea:	90 81       	ld	r25, Z
 1ec:	9f 4f       	sbci	r25, 0xFF	; 255
 1ee:	91 93       	st	Z+, r25
 1f0:	90 81       	ld	r25, Z
 1f2:	9f 4f       	sbci	r25, 0xFF	; 255
 1f4:	91 93       	st	Z+, r25
 1f6:	26 f3       	brts	.-56     	; 0x1c0 <ovf_end>

000001f8 <sub_end>:
 1f8:	9f 91       	pop	r25
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:379
        [MINCD]  "M" ((0xFFFF - MILLIS_INC) & 0xFF)
      );
    #endif /* (defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)) */
    // Common ISR Epilogue for TCA, TCB and TCD, popping register in reverse Order
    // 6 words, 14 clocks
    __asm__ __volatile__(
 1fa:	ff 91       	pop	r31
 1fc:	ef 91       	pop	r30
 1fe:	8f 91       	pop	r24
 200:	8f bf       	out	0x3f, r24	; 63
 202:	8f 91       	pop	r24
 204:	18 95       	reti

00000206 <__vector_13>:
__vector_13():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:317
  #if defined(USE_TIMERB0)
  ISR(TCB0_INT_vect)
  #elif defined(USE_TIMERB1)
  ISR(TCB1_INT_vect)
  #endif
  {
 206:	1f 92       	push	r1
 208:	0f 92       	push	r0
 20a:	0f b6       	in	r0, 0x3f	; 63
 20c:	0f 92       	push	r0
 20e:	11 24       	eor	r1, r1
 210:	2f 93       	push	r18
 212:	3f 93       	push	r19
 214:	4f 93       	push	r20
 216:	5f 93       	push	r21
 218:	6f 93       	push	r22
 21a:	7f 93       	push	r23
 21c:	8f 93       	push	r24
 21e:	9f 93       	push	r25
 220:	af 93       	push	r26
 222:	bf 93       	push	r27
 224:	ef 93       	push	r30
 226:	ff 93       	push	r31
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:318
    if (!(--timer_cycle_per_tgl_count)) { // Are we ready to toggle? pre-decrement, then see if we're at 0 yet.
 228:	80 91 02 3f 	lds	r24, 0x3F02	; 0x803f02 <__data_end>
 22c:	81 50       	subi	r24, 0x01	; 1
 22e:	80 93 02 3f 	sts	0x3F02, r24	; 0x803f02 <__data_end>
 232:	81 11       	cpse	r24, r1
 234:	2b c0       	rjmp	.+86     	; 0x28c <__vector_13+0x86>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:319
      timer_cycle_per_tgl_count   = timer_cycle_per_tgl;  // reset countdown
 236:	80 91 03 3f 	lds	r24, 0x3F03	; 0x803f03 <timer_cycle_per_tgl>
 23a:	80 93 02 3f 	sts	0x3F02, r24	; 0x803f02 <__data_end>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:320
      *timer_outtgl_reg           = timer_bit_mask;       // toggle the pin
 23e:	e0 91 09 3f 	lds	r30, 0x3F09	; 0x803f09 <timer_outtgl_reg>
 242:	f0 91 0a 3f 	lds	r31, 0x3F0A	; 0x803f0a <timer_outtgl_reg+0x1>
 246:	80 91 08 3f 	lds	r24, 0x3F08	; 0x803f08 <timer_bit_mask>
 24a:	80 83       	st	Z, r24
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:321
      if (timer_toggle_count > 0) {  // if duration was specified, decrement toggle count.
 24c:	80 91 04 3f 	lds	r24, 0x3F04	; 0x803f04 <timer_toggle_count>
 250:	90 91 05 3f 	lds	r25, 0x3F05	; 0x803f05 <timer_toggle_count+0x1>
 254:	a0 91 06 3f 	lds	r26, 0x3F06	; 0x803f06 <timer_toggle_count+0x2>
 258:	b0 91 07 3f 	lds	r27, 0x3F07	; 0x803f07 <timer_toggle_count+0x3>
 25c:	18 16       	cp	r1, r24
 25e:	19 06       	cpc	r1, r25
 260:	1a 06       	cpc	r1, r26
 262:	1b 06       	cpc	r1, r27
 264:	3c f5       	brge	.+78     	; 0x2b4 <__vector_13+0xae>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:322
          timer_toggle_count--;
 266:	80 91 04 3f 	lds	r24, 0x3F04	; 0x803f04 <timer_toggle_count>
 26a:	90 91 05 3f 	lds	r25, 0x3F05	; 0x803f05 <timer_toggle_count+0x1>
 26e:	a0 91 06 3f 	lds	r26, 0x3F06	; 0x803f06 <timer_toggle_count+0x2>
 272:	b0 91 07 3f 	lds	r27, 0x3F07	; 0x803f07 <timer_toggle_count+0x3>
 276:	01 97       	sbiw	r24, 0x01	; 1
 278:	a1 09       	sbc	r26, r1
 27a:	b1 09       	sbc	r27, r1
 27c:	80 93 04 3f 	sts	0x3F04, r24	; 0x803f04 <timer_toggle_count>
 280:	90 93 05 3f 	sts	0x3F05, r25	; 0x803f05 <timer_toggle_count+0x1>
 284:	a0 93 06 3f 	sts	0x3F06, r26	; 0x803f06 <timer_toggle_count+0x2>
 288:	b0 93 07 3f 	sts	0x3F07, r27	; 0x803f07 <timer_toggle_count+0x3>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:327
      } else if (timer_toggle_count == 0) {       // If toggle count = 0 we are done.
        disableTimer();
      } //  otherwise timer_toggle_count wasn't supplied, go on until noTone() called
    }
    _timer->INTFLAGS = TCB_CAPT_bm; // Clear flag
 28c:	81 e0       	ldi	r24, 0x01	; 1
 28e:	80 93 46 0a 	sts	0x0A46, r24	; 0x800a46 <digital_pin_to_bit_mask+0x7f7eb0>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:328
  }
 292:	ff 91       	pop	r31
 294:	ef 91       	pop	r30
 296:	bf 91       	pop	r27
 298:	af 91       	pop	r26
 29a:	9f 91       	pop	r25
 29c:	8f 91       	pop	r24
 29e:	7f 91       	pop	r23
 2a0:	6f 91       	pop	r22
 2a2:	5f 91       	pop	r21
 2a4:	4f 91       	pop	r20
 2a6:	3f 91       	pop	r19
 2a8:	2f 91       	pop	r18
 2aa:	0f 90       	pop	r0
 2ac:	0f be       	out	0x3f, r0	; 63
 2ae:	0f 90       	pop	r0
 2b0:	1f 90       	pop	r1
 2b2:	18 95       	reti
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:323
    if (!(--timer_cycle_per_tgl_count)) { // Are we ready to toggle? pre-decrement, then see if we're at 0 yet.
      timer_cycle_per_tgl_count   = timer_cycle_per_tgl;  // reset countdown
      *timer_outtgl_reg           = timer_bit_mask;       // toggle the pin
      if (timer_toggle_count > 0) {  // if duration was specified, decrement toggle count.
          timer_toggle_count--;
      } else if (timer_toggle_count == 0) {       // If toggle count = 0 we are done.
 2b4:	80 91 04 3f 	lds	r24, 0x3F04	; 0x803f04 <timer_toggle_count>
 2b8:	90 91 05 3f 	lds	r25, 0x3F05	; 0x803f05 <timer_toggle_count+0x1>
 2bc:	a0 91 06 3f 	lds	r26, 0x3F06	; 0x803f06 <timer_toggle_count+0x2>
 2c0:	b0 91 07 3f 	lds	r27, 0x3F07	; 0x803f07 <timer_toggle_count+0x3>
 2c4:	89 2b       	or	r24, r25
 2c6:	8a 2b       	or	r24, r26
 2c8:	8b 2b       	or	r24, r27
 2ca:	01 f7       	brne	.-64     	; 0x28c <__vector_13+0x86>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:324
        disableTimer();
 2cc:	f6 de       	rcall	.-532    	; 0xba <disableTimer()>
 2ce:	de cf       	rjmp	.-68     	; 0x28c <__vector_13+0x86>

000002d0 <__vector_3>:
__vector_3():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:121
  // Execution continues here after waking up
  sleep_disable();                     // Disable sleep mode after waking up
}

// Interrupt Service Routine for pin change on PA2
ISR(PORTA_PORT_vect) {
 2d0:	1f 92       	push	r1
 2d2:	0f 92       	push	r0
 2d4:	0f b6       	in	r0, 0x3f	; 63
 2d6:	0f 92       	push	r0
 2d8:	11 24       	eor	r1, r1
 2da:	8f 93       	push	r24
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:123
  // Clear interrupt flag for PA2
  PORTA.INTFLAGS = PORT_INT2_bm;
 2dc:	84 e0       	ldi	r24, 0x04	; 4
 2de:	80 93 09 04 	sts	0x0409, r24	; 0x800409 <digital_pin_to_bit_mask+0x7f7873>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:125
  // Set wake-up flag
  wakeUpFlag = true;
 2e2:	81 e0       	ldi	r24, 0x01	; 1
 2e4:	80 93 1f 3f 	sts	0x3F1F, r24	; 0x803f1f <wakeUpFlag>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:126
}
 2e8:	8f 91       	pop	r24
 2ea:	0f 90       	pop	r0
 2ec:	0f be       	out	0x3f, r0	; 63
 2ee:	0f 90       	pop	r0
 2f0:	1f 90       	pop	r1
 2f2:	18 95       	reti

000002f4 <main>:
main():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1542
      #elif (F_CPU == 16000000)
        /* No division on clock */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
      #elif (F_CPU == 10000000) // 20MHz prescaled by 2
        /* Clock DIV2 */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, (CLKCTRL_PEN_bm | CLKCTRL_PDIV_2X_gc));
 2f4:	81 e0       	ldi	r24, 0x01	; 1
 2f6:	98 ed       	ldi	r25, 0xD8	; 216
 2f8:	94 bf       	out	0x34, r25	; 52
 2fa:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <digital_pin_to_bit_mask+0x7f74cb>
init_ADC0():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1651


/********************************* ADC ****************************************/
void __attribute__((weak)) init_ADC0() {
  ADC_t* pADC;
  _fastPtr_d(pADC, &ADC0);
 2fe:	e0 e0       	ldi	r30, 0x00	; 0
 300:	f6 e0       	ldi	r31, 0x06	; 6
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1674
    #if   F_CPU   > 24000000     // 24 MHz / 16 = 1.5 MHz,  25 MHz / 32 =  780 kHz
      pADC->CTRLC  = ADC_PRESC_DIV32_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #elif F_CPU  >= 12000000    // 16 MHz / 16 = 1.0 MHz,  20 MHz / 16 = 1.25 MHz
      pADC->CTRLC  = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #elif F_CPU  >=  6000000    //  8 MHz /  8 = 1.0 MHz,  10 MHz /  8 = 1.25 MHz
      pADC->CTRLC  =  ADC_PRESC_DIV8_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
 302:	92 e5       	ldi	r25, 0x52	; 82
 304:	92 83       	std	Z+2, r25	; 0x02
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1683
      pADC->CTRLC  =  ADC_PRESC_DIV2_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #endif
    #if   (F_CPU == 6000000 || F_CPU == 12000000 || F_CPU == 24000000 || F_CPU ==25000000)
      pADC->SAMPCTRL = (7); // 9 ADC clocks, 12 us
    #elif (F_CPU == 5000000 || F_CPU == 10000000 || F_CPU == 20000000)
      pADC->SAMPCTRL = (13);   // 15 ADC clock,s 12 us
 306:	9d e0       	ldi	r25, 0x0D	; 13
 308:	95 83       	std	Z+5, r25	; 0x05
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1687
    #else
      pADC->SAMPCTRL = (10); // 12 ADC clocks, 12 us
    #endif
    pADC->CTRLD    = ADC_INITDLY_DLY16_gc;
 30a:	90 e2       	ldi	r25, 0x20	; 32
 30c:	93 83       	std	Z+3, r25	; 0x03
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1688
    pADC->CTRLA    = ADC_ENABLE_bm;
 30e:	80 83       	st	Z, r24
init_TCA0():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1778

void __attribute__((weak)) init_TCA0() {
  /*  TYPE A TIMER   */
  #if !defined(TCA_BUFFERED_3PIN)
    #if defined(PORTMUX_CTRLC)
      PORTMUX.CTRLC = TCA_PORTMUX;
 310:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <digital_pin_to_bit_mask+0x7f766c>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1782
    #else
      PORTMUX.TCAROUTEA = TCA_PORTMUX;
    #endif
    TCA0.SPLIT.CTRLD   = TCA_SPLIT_SPLITM_bm;
 314:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <digital_pin_to_bit_mask+0x7f7e6d>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1783
    TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
 318:	8e ef       	ldi	r24, 0xFE	; 254
 31a:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <digital_pin_to_bit_mask+0x7f7e90>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1784
    TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
 31e:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <digital_pin_to_bit_mask+0x7f7e91>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1785
    TCA0.SPLIT.CTRLA   = (TIMERA_PRESCALER_bm | TCA_SPLIT_ENABLE_bm);
 322:	8b e0       	ldi	r24, 0x0B	; 11
 324:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <digital_pin_to_bit_mask+0x7f7e6a>
init_millis():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring.c:1419
  #if defined(MILLIS_USE_TIMERNONE)
    badCall("init_millis() is only valid with millis time keeping enabled.");
  #else
    #if defined(MILLIS_USE_TIMERA0)
      #if !defined(TCA_BUFFERED_3PIN)
        TCA0.SPLIT.INTCTRL = TCA_SPLIT_HUNF_bm;
 328:	82 e0       	ldi	r24, 0x02	; 2
 32a:	80 93 0a 0a 	sts	0x0A0A, r24	; 0x800a0a <digital_pin_to_bit_mask+0x7f7e74>
main():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/main.cpp:53
 * just waiting for the DU-series now                                                           */
int main() {
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
 32e:	78 94       	sei
pinMode():
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
  } else { // otherwise it's input so we write DIRCLR
    *(port_base + 2) = bit_mask;
 330:	84 e0       	ldi	r24, 0x04	; 4
 332:	80 93 02 04 	sts	0x0402, r24	; 0x800402 <digital_pin_to_bit_mask+0x7f786c>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:78
  // by 2 bytes and one clock. And let's hope it is, because the code above would suck too if it was in X.
  // Handwritten assembly that exploited the knowledge that there will never be a carry would save 1 word and 1 clock.
  // and could probably save at least several times that in initializing the port_base pointer. But if you're using
  // pinMode you probably don't care.
  port_base += (uint8_t) digitalPinToBitPosition(pin);
  bit_mask = *(port_base + 0x10);
 336:	80 91 12 04 	lds	r24, 0x0412	; 0x800412 <digital_pin_to_bit_mask+0x7f787c>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:80
  if (mode & 2) {
    bit_mask |= 0x08;
 33a:	88 60       	ori	r24, 0x08	; 8
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:84
  } else {
    bit_mask &= 0xF7;
  }
  *(port_base + 0x10) = bit_mask;
 33c:	80 93 12 04 	sts	0x0412, r24	; 0x800412 <digital_pin_to_bit_mask+0x7f787c>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:51
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
 340:	88 e0       	ldi	r24, 0x08	; 8
 342:	80 93 01 04 	sts	0x0401, r24	; 0x800401 <digital_pin_to_bit_mask+0x7f786b>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:78
  // by 2 bytes and one clock. And let's hope it is, because the code above would suck too if it was in X.
  // Handwritten assembly that exploited the knowledge that there will never be a carry would save 1 word and 1 clock.
  // and could probably save at least several times that in initializing the port_base pointer. But if you're using
  // pinMode you probably don't care.
  port_base += (uint8_t) digitalPinToBitPosition(pin);
  bit_mask = *(port_base + 0x10);
 346:	80 91 13 04 	lds	r24, 0x0413	; 0x800413 <digital_pin_to_bit_mask+0x7f787d>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:82
  if (mode & 2) {
    bit_mask |= 0x08;
  } else {
    bit_mask &= 0xF7;
 34a:	87 7f       	andi	r24, 0xF7	; 247
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:84
  }
  *(port_base + 0x10) = bit_mask;
 34c:	80 93 13 04 	sts	0x0413, r24	; 0x800413 <digital_pin_to_bit_mask+0x7f787d>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:51
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
 350:	80 e8       	ldi	r24, 0x80	; 128
 352:	80 93 01 04 	sts	0x0401, r24	; 0x800401 <digital_pin_to_bit_mask+0x7f786b>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:78
  // by 2 bytes and one clock. And let's hope it is, because the code above would suck too if it was in X.
  // Handwritten assembly that exploited the knowledge that there will never be a carry would save 1 word and 1 clock.
  // and could probably save at least several times that in initializing the port_base pointer. But if you're using
  // pinMode you probably don't care.
  port_base += (uint8_t) digitalPinToBitPosition(pin);
  bit_mask = *(port_base + 0x10);
 356:	80 91 17 04 	lds	r24, 0x0417	; 0x800417 <digital_pin_to_bit_mask+0x7f7881>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:82
  if (mode & 2) {
    bit_mask |= 0x08;
  } else {
    bit_mask &= 0xF7;
 35a:	87 7f       	andi	r24, 0xF7	; 247
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/wiring_digital.c:84
  }
  *(port_base + 0x10) = bit_mask;
 35c:	80 93 17 04 	sts	0x0417, r24	; 0x800417 <digital_pin_to_bit_mask+0x7f7881>
setup():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:21

void setup() {
  pinMode(buttonPin, INPUT_PULLUP); // Set button pin as input with pull-up resistor
  pinMode(ledPin, OUTPUT);          // Set LED pin as output
  pinMode(piezoPin, OUTPUT);        // Set Piezo pin as output
  digitalWrite(ledPin, LOW);        // Initialize LED to off
 360:	60 e0       	ldi	r22, 0x00	; 0
 362:	84 e0       	ldi	r24, 0x04	; 4
 364:	d3 de       	rcall	.-602    	; 0x10c <digitalWrite>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:22
  digitalWrite(piezoPin, LOW);      // Initialize Piezo to off
 366:	60 e0       	ldi	r22, 0x00	; 0
 368:	81 e0       	ldi	r24, 0x01	; 1
 36a:	d0 de       	rcall	.-608    	; 0x10c <digitalWrite>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:25

  // Enable interrupts on PA2 (buttonPin)
  PORTA.PIN2CTRL = PORT_PULLUPEN_bm | PORT_ISC_BOTHEDGES_gc; // Enable pull-up and interrupt on both edges
 36c:	89 e0       	ldi	r24, 0x09	; 9
 36e:	80 93 12 04 	sts	0x0412, r24	; 0x800412 <digital_pin_to_bit_mask+0x7f787c>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:26
  sei(); // Enable global interrupts
 372:	78 94       	sei
tone():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:210
    }
    // Calculate compare value
    int8_t divisionfactor = 0; // no prescale, toggles at twice the frequency

    // Timer settings -- will be type B timer or bust....
    uint32_t compare_val = ((F_CPU / frequency) >> 1);
 374:	50 e8       	ldi	r21, 0x80	; 128
 376:	85 2e       	mov	r8, r21
 378:	56 e9       	ldi	r21, 0x96	; 150
 37a:	95 2e       	mov	r9, r21
 37c:	58 e9       	ldi	r21, 0x98	; 152
 37e:	a5 2e       	mov	r10, r21
 380:	b1 2c       	mov	r11, r1
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:256
      *(timer_outtgl_reg - 1)  = bit_mask;                              // digitalWrite(pin, LOW);
      *(timer_outtgl_reg - 6)  = bit_mask;                              // pinMode(pin, OUTPUT);
    }
    // Save the results of our calculations
    timer_toggle_count         = toggle_count;
    timer_cycle_per_tgl        = 1 << divisionfactor;     // 1, 2, 4, 8, 16, 32, or 64 - toggle pin once per this many cycles...
 382:	01 e0       	ldi	r16, 0x01	; 1
 384:	10 e0       	ldi	r17, 0x00	; 0
loop():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:49
      buttonPressTime = millis(); // Record the time the button was first pressed
    }
    
    // Check if the button is held for  seconds
    if (!buttonHeld && millis() - buttonPressTime >= 2000) {
      buttonHeld = true;          // Mark as held
 386:	33 24       	eor	r3, r3
 388:	33 94       	inc	r3
tone():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:255
      timer_outtgl_reg         = (volatile uint8_t *) &(port->OUTTGL);  // or toggle register.
      *(timer_outtgl_reg - 1)  = bit_mask;                              // digitalWrite(pin, LOW);
      *(timer_outtgl_reg - 6)  = bit_mask;                              // pinMode(pin, OUTPUT);
    }
    // Save the results of our calculations
    timer_toggle_count         = toggle_count;
 38a:	44 24       	eor	r4, r4
 38c:	4a 94       	dec	r4
 38e:	54 2c       	mov	r5, r4
 390:	32 01       	movw	r6, r4
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:250
        *(timer_outtgl_reg - 1) = timer_bit_mask; // digitalWrite(_pin, LOW); (write outclr for old pin)
      }
      // whether or not we _were_ using a pin, we are now, so configure the new one as an output...
      PORT_t *port             = digitalPinToPortStruct(pin);           // Since not known at compile time, use PORTs not VPORTS.
      timer_bit_mask           = bit_mask;                              // We no longer need old pin's bit_mask
      timer_outtgl_reg         = (volatile uint8_t *) &(port->OUTTGL);  // or toggle register.
 392:	c7 e0       	ldi	r28, 0x07	; 7
 394:	d4 e0       	ldi	r29, 0x04	; 4
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:249
        // It does need to be LOW though, otherwise it can damage some speakers!
        *(timer_outtgl_reg - 1) = timer_bit_mask; // digitalWrite(_pin, LOW); (write outclr for old pin)
      }
      // whether or not we _were_ using a pin, we are now, so configure the new one as an output...
      PORT_t *port             = digitalPinToPortStruct(pin);           // Since not known at compile time, use PORTs not VPORTS.
      timer_bit_mask           = bit_mask;                              // We no longer need old pin's bit_mask
 396:	40 e8       	ldi	r20, 0x80	; 128
 398:	24 2e       	mov	r2, r20
loop():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:31
  sei(); // Enable global interrupts
}

void loop() {
  // Check the wake-up flag
  if (wakeUpFlag) {
 39a:	80 91 1f 3f 	lds	r24, 0x3F1F	; 0x803f1f <wakeUpFlag>
 39e:	88 23       	and	r24, r24
 3a0:	59 f0       	breq	.+22     	; 0x3b8 <main+0xc4>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:32
    wakeUpFlag = false; // Clear the flag
 3a2:	10 92 1f 3f 	sts	0x3F1F, r1	; 0x803f1f <wakeUpFlag>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:33
    wakeUpMillis = millis(); // Record the time of wake-up
 3a6:	7d de       	rcall	.-774    	; 0xa2 <millis>
 3a8:	60 93 1b 3f 	sts	0x3F1B, r22	; 0x803f1b <wakeUpMillis>
 3ac:	70 93 1c 3f 	sts	0x3F1C, r23	; 0x803f1c <wakeUpMillis+0x1>
 3b0:	80 93 1d 3f 	sts	0x3F1D, r24	; 0x803f1d <wakeUpMillis+0x2>
 3b4:	90 93 1e 3f 	sts	0x3F1E, r25	; 0x803f1e <wakeUpMillis+0x3>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:37
  }

  // Delay after wake-up to process button inputs
  if (millis() - wakeUpMillis < wakeUpDebounce) {
 3b8:	74 de       	rcall	.-792    	; 0xa2 <millis>
 3ba:	c0 90 1b 3f 	lds	r12, 0x3F1B	; 0x803f1b <wakeUpMillis>
 3be:	d0 90 1c 3f 	lds	r13, 0x3F1C	; 0x803f1c <wakeUpMillis+0x1>
 3c2:	e0 90 1d 3f 	lds	r14, 0x3F1D	; 0x803f1d <wakeUpMillis+0x2>
 3c6:	f0 90 1e 3f 	lds	r15, 0x3F1E	; 0x803f1e <wakeUpMillis+0x3>
 3ca:	6c 19       	sub	r22, r12
 3cc:	7d 09       	sbc	r23, r13
 3ce:	8e 09       	sbc	r24, r14
 3d0:	9f 09       	sbc	r25, r15
 3d2:	64 36       	cpi	r22, 0x64	; 100
 3d4:	71 05       	cpc	r23, r1
 3d6:	81 05       	cpc	r24, r1
 3d8:	91 05       	cpc	r25, r1
 3da:	f8 f2       	brcs	.-66     	; 0x39a <main+0xa6>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:42
    return;
  }

  // Check button state
  if (digitalRead(buttonPin) == LOW) { // Button is pressed
 3dc:	91 de       	rcall	.-734    	; 0x100 <digitalRead.constprop.0>
 3de:	81 11       	cpse	r24, r1
 3e0:	65 c0       	rjmp	.+202    	; 0x4ac <__LOCK_REGION_LENGTH__+0xac>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:43
    if (buttonPressTime == 0) {
 3e2:	80 91 17 3f 	lds	r24, 0x3F17	; 0x803f17 <buttonPressTime>
 3e6:	90 91 18 3f 	lds	r25, 0x3F18	; 0x803f18 <buttonPressTime+0x1>
 3ea:	a0 91 19 3f 	lds	r26, 0x3F19	; 0x803f19 <buttonPressTime+0x2>
 3ee:	b0 91 1a 3f 	lds	r27, 0x3F1A	; 0x803f1a <buttonPressTime+0x3>
 3f2:	89 2b       	or	r24, r25
 3f4:	8a 2b       	or	r24, r26
 3f6:	8b 2b       	or	r24, r27
 3f8:	49 f4       	brne	.+18     	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:44
      buttonPressTime = millis(); // Record the time the button was first pressed
 3fa:	53 de       	rcall	.-858    	; 0xa2 <millis>
 3fc:	60 93 17 3f 	sts	0x3F17, r22	; 0x803f17 <buttonPressTime>
 400:	70 93 18 3f 	sts	0x3F18, r23	; 0x803f18 <buttonPressTime+0x1>
 404:	80 93 19 3f 	sts	0x3F19, r24	; 0x803f19 <buttonPressTime+0x2>
 408:	90 93 1a 3f 	sts	0x3F1A, r25	; 0x803f1a <buttonPressTime+0x3>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:48
    }
    
    // Check if the button is held for  seconds
    if (!buttonHeld && millis() - buttonPressTime >= 2000) {
 40c:	80 91 16 3f 	lds	r24, 0x3F16	; 0x803f16 <buttonHeld>
 410:	81 11       	cpse	r24, r1
 412:	1a c0       	rjmp	.+52     	; 0x448 <__LOCK_REGION_LENGTH__+0x48>
 414:	f0 90 15 3f 	lds	r15, 0x3F15	; 0x803f15 <alarmState>
 418:	44 de       	rcall	.-888    	; 0xa2 <millis>
 41a:	20 91 17 3f 	lds	r18, 0x3F17	; 0x803f17 <buttonPressTime>
 41e:	30 91 18 3f 	lds	r19, 0x3F18	; 0x803f18 <buttonPressTime+0x1>
 422:	40 91 19 3f 	lds	r20, 0x3F19	; 0x803f19 <buttonPressTime+0x2>
 426:	50 91 1a 3f 	lds	r21, 0x3F1A	; 0x803f1a <buttonPressTime+0x3>
 42a:	62 1b       	sub	r22, r18
 42c:	73 0b       	sbc	r23, r19
 42e:	84 0b       	sbc	r24, r20
 430:	95 0b       	sbc	r25, r21
 432:	60 3d       	cpi	r22, 0xD0	; 208
 434:	77 40       	sbci	r23, 0x07	; 7
 436:	81 05       	cpc	r24, r1
 438:	91 05       	cpc	r25, r1
 43a:	30 f0       	brcs	.+12     	; 0x448 <__LOCK_REGION_LENGTH__+0x48>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:49
      buttonHeld = true;          // Mark as held
 43c:	30 92 16 3f 	sts	0x3F16, r3	; 0x803f16 <buttonHeld>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:50
      alarmState = !alarmState;   // Toggle the alarm state
 440:	41 e0       	ldi	r20, 0x01	; 1
 442:	f4 26       	eor	r15, r20
 444:	f0 92 15 3f 	sts	0x3F15, r15	; 0x803f15 <alarmState>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:58
    buttonPressTime = 0;          // Reset the press time
    buttonHeld = false;           // Reset the held state
  }

  // Play Alarm
  if (alarmState) {
 448:	80 91 15 3f 	lds	r24, 0x3F15	; 0x803f15 <alarmState>
 44c:	88 23       	and	r24, r24
 44e:	09 f4       	brne	.+2      	; 0x452 <__LOCK_REGION_LENGTH__+0x52>
 450:	2b c1       	rjmp	.+598    	; 0x6a8 <__LOCK_REGION_LENGTH__+0x2a8>
alarmTone():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:81
  const unsigned long silenceDuration = 500; // Duration for silence (in ms)
  const unsigned long toneInterval = 1; // Interval for tone update (in ms)
  static int x = 0;
  static bool isToneActive = true; // Whether tone is currently active

  unsigned long currentMillis = millis();
 452:	27 de       	rcall	.-946    	; 0xa2 <millis>
 454:	6b 01       	movw	r12, r22
 456:	7c 01       	movw	r14, r24
 458:	80 91 11 3f 	lds	r24, 0x3F11	; 0x803f11 <alarmTone()::silenceStartMillis>
 45c:	90 91 12 3f 	lds	r25, 0x3F12	; 0x803f12 <alarmTone()::silenceStartMillis+0x1>
 460:	a0 91 13 3f 	lds	r26, 0x3F13	; 0x803f13 <alarmTone()::silenceStartMillis+0x2>
 464:	b0 91 14 3f 	lds	r27, 0x3F14	; 0x803f14 <alarmTone()::silenceStartMillis+0x3>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:83
  
  if (isToneActive) {
 468:	20 91 01 3f 	lds	r18, 0x3F01	; 0x803f01 <alarmTone()::isToneActive>
 46c:	b7 01       	movw	r22, r14
 46e:	a6 01       	movw	r20, r12
 470:	48 1b       	sub	r20, r24
 472:	59 0b       	sbc	r21, r25
 474:	6a 0b       	sbc	r22, r26
 476:	7b 0b       	sbc	r23, r27
 478:	db 01       	movw	r26, r22
 47a:	ca 01       	movw	r24, r20
 47c:	22 23       	and	r18, r18
 47e:	09 f4       	brne	.+2      	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
 480:	0a c1       	rjmp	.+532    	; 0x696 <__LOCK_REGION_LENGTH__+0x296>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:85
    // Check if it's time to stop the tone
    if (currentMillis - silenceStartMillis >= toneDuration) {
 482:	80 3d       	cpi	r24, 0xD0	; 208
 484:	97 40       	sbci	r25, 0x07	; 7
 486:	a1 05       	cpc	r26, r1
 488:	b1 05       	cpc	r27, r1
 48a:	d8 f0       	brcs	.+54     	; 0x4c2 <__LOCK_REGION_LENGTH__+0xc2>
noTone():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:274
#endif

// pin which currently is being used for a tone
#ifndef TONE_UNAVAILABLE
  void noTone(uint8_t pin) {
    if (pin == _pin) {
 48c:	80 91 00 3f 	lds	r24, 0x3F00	; 0x803f00 <__DATA_REGION_ORIGIN__>
 490:	81 30       	cpi	r24, 0x01	; 1
 492:	09 f4       	brne	.+2      	; 0x496 <__LOCK_REGION_LENGTH__+0x96>
 494:	23 de       	rcall	.-954    	; 0xdc <noTone(unsigned char) [clone .part.0]>
alarmTone():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:87
      noTone(piezoPin); // Stop the tone
      isToneActive = false; // Switch to silence period
 496:	10 92 01 3f 	sts	0x3F01, r1	; 0x803f01 <alarmTone()::isToneActive>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:106
    }
  } else {
    // Check if silence period is over
    if (currentMillis - silenceStartMillis >= silenceDuration) {
      isToneActive = true; // Switch back to tone generation
      silenceStartMillis = currentMillis; // Mark tone start time
 49a:	c0 92 11 3f 	sts	0x3F11, r12	; 0x803f11 <alarmTone()::silenceStartMillis>
 49e:	d0 92 12 3f 	sts	0x3F12, r13	; 0x803f12 <alarmTone()::silenceStartMillis+0x1>
 4a2:	e0 92 13 3f 	sts	0x3F13, r14	; 0x803f13 <alarmTone()::silenceStartMillis+0x2>
 4a6:	f0 92 14 3f 	sts	0x3F14, r15	; 0x803f14 <alarmTone()::silenceStartMillis+0x3>
 4aa:	4c c0       	rjmp	.+152    	; 0x544 <__LOCK_REGION_LENGTH__+0x144>
loop():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:53
    if (!buttonHeld && millis() - buttonPressTime >= 2000) {
      buttonHeld = true;          // Mark as held
      alarmState = !alarmState;   // Toggle the alarm state
    }
  } else { // Button is released
    buttonPressTime = 0;          // Reset the press time
 4ac:	10 92 17 3f 	sts	0x3F17, r1	; 0x803f17 <buttonPressTime>
 4b0:	10 92 18 3f 	sts	0x3F18, r1	; 0x803f18 <buttonPressTime+0x1>
 4b4:	10 92 19 3f 	sts	0x3F19, r1	; 0x803f19 <buttonPressTime+0x2>
 4b8:	10 92 1a 3f 	sts	0x3F1A, r1	; 0x803f1a <buttonPressTime+0x3>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:54
    buttonHeld = false;           // Reset the held state
 4bc:	10 92 16 3f 	sts	0x3F16, r1	; 0x803f16 <buttonHeld>
 4c0:	c3 cf       	rjmp	.-122    	; 0x448 <__LOCK_REGION_LENGTH__+0x48>
alarmTone():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:89
    // Check if it's time to stop the tone
    if (currentMillis - silenceStartMillis >= toneDuration) {
      noTone(piezoPin); // Stop the tone
      isToneActive = false; // Switch to silence period
      silenceStartMillis = currentMillis; // Mark silence start time
    } else if (currentMillis - previousToneMillis >= toneInterval) {
 4c2:	80 91 0d 3f 	lds	r24, 0x3F0D	; 0x803f0d <alarmTone()::previousToneMillis>
 4c6:	90 91 0e 3f 	lds	r25, 0x3F0E	; 0x803f0e <alarmTone()::previousToneMillis+0x1>
 4ca:	a0 91 0f 3f 	lds	r26, 0x3F0F	; 0x803f0f <alarmTone()::previousToneMillis+0x2>
 4ce:	b0 91 10 3f 	lds	r27, 0x3F10	; 0x803f10 <alarmTone()::previousToneMillis+0x3>
 4d2:	c8 16       	cp	r12, r24
 4d4:	d9 06       	cpc	r13, r25
 4d6:	ea 06       	cpc	r14, r26
 4d8:	fb 06       	cpc	r15, r27
 4da:	a1 f1       	breq	.+104    	; 0x544 <__LOCK_REGION_LENGTH__+0x144>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:90
      previousToneMillis = currentMillis;
 4dc:	c0 92 0d 3f 	sts	0x3F0D, r12	; 0x803f0d <alarmTone()::previousToneMillis>
 4e0:	d0 92 0e 3f 	sts	0x3F0E, r13	; 0x803f0e <alarmTone()::previousToneMillis+0x1>
 4e4:	e0 92 0f 3f 	sts	0x3F0F, r14	; 0x803f0f <alarmTone()::previousToneMillis+0x2>
 4e8:	f0 92 10 3f 	sts	0x3F10, r15	; 0x803f10 <alarmTone()::previousToneMillis+0x3>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:93

      // Generate sine wave tone between 3700 Hz and 4200 Hz
      float sinVal = sin(x * (3.1412 / 180)); // x is in degrees
 4ec:	60 91 0b 3f 	lds	r22, 0x3F0B	; 0x803f0b <alarmTone()::x>
 4f0:	70 91 0c 3f 	lds	r23, 0x3F0C	; 0x803f0c <alarmTone()::x+0x1>
 4f4:	07 2e       	mov	r0, r23
 4f6:	00 0c       	add	r0, r0
 4f8:	88 0b       	sbc	r24, r24
 4fa:	99 0b       	sbc	r25, r25
 4fc:	14 d1       	rcall	.+552    	; 0x726 <__floatsisf>
 4fe:	22 ea       	ldi	r18, 0xA2	; 162
 500:	35 ef       	ldi	r19, 0xF5	; 245
 502:	4e e8       	ldi	r20, 0x8E	; 142
 504:	5c e3       	ldi	r21, 0x3C	; 60
 506:	73 d1       	rcall	.+742    	; 0x7ee <__mulsf3>
 508:	df d1       	rcall	.+958    	; 0x8c8 <sin>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:94
      int toneVal = 3950 + (int(sinVal * 200)); // Center at 3950 Hz, amplitude 250 Hz
 50a:	20 e0       	ldi	r18, 0x00	; 0
 50c:	30 e0       	ldi	r19, 0x00	; 0
 50e:	48 e4       	ldi	r20, 0x48	; 72
 510:	53 e4       	ldi	r21, 0x43	; 67
 512:	6d d1       	rcall	.+730    	; 0x7ee <__mulsf3>
 514:	d0 d0       	rcall	.+416    	; 0x6b6 <__fixsfsi>
 516:	62 59       	subi	r22, 0x92	; 146
 518:	70 4f       	sbci	r23, 0xF0	; 240
tone():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:161

// frequency (in hertz) and duration (in milliseconds).
#ifndef TONE_UNAVAILABLE
  void tone(uint8_t pin, unsigned int frequency, unsigned long duration) {
    // Believe it or not, we don't need to turn off interrupts!
    if (frequency == 0) {
 51a:	09 f0       	breq	.+2      	; 0x51e <__LOCK_REGION_LENGTH__+0x11e>
 51c:	43 c0       	rjmp	.+134    	; 0x5a4 <__LOCK_REGION_LENGTH__+0x1a4>
noTone():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:274
#endif

// pin which currently is being used for a tone
#ifndef TONE_UNAVAILABLE
  void noTone(uint8_t pin) {
    if (pin == _pin) {
 51e:	80 91 00 3f 	lds	r24, 0x3F00	; 0x803f00 <__DATA_REGION_ORIGIN__>
 522:	81 30       	cpi	r24, 0x01	; 1
 524:	09 f4       	brne	.+2      	; 0x528 <__LOCK_REGION_LENGTH__+0x128>
 526:	da dd       	rcall	.-1100   	; 0xdc <noTone(unsigned char) [clone .part.0]>
alarmTone():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:97
      tone(piezoPin, toneVal);

      x++;
 528:	80 91 0b 3f 	lds	r24, 0x3F0B	; 0x803f0b <alarmTone()::x>
 52c:	90 91 0c 3f 	lds	r25, 0x3F0C	; 0x803f0c <alarmTone()::x+0x1>
 530:	01 96       	adiw	r24, 0x01	; 1
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:98
      if (x >= 360) {
 532:	88 36       	cpi	r24, 0x68	; 104
 534:	21 e0       	ldi	r18, 0x01	; 1
 536:	92 07       	cpc	r25, r18
 538:	0c f0       	brlt	.+2      	; 0x53c <__LOCK_REGION_LENGTH__+0x13c>
 53a:	a8 c0       	rjmp	.+336    	; 0x68c <__LOCK_REGION_LENGTH__+0x28c>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:97
      // Generate sine wave tone between 3700 Hz and 4200 Hz
      float sinVal = sin(x * (3.1412 / 180)); // x is in degrees
      int toneVal = 3950 + (int(sinVal * 200)); // Center at 3950 Hz, amplitude 250 Hz
      tone(piezoPin, toneVal);

      x++;
 53c:	80 93 0b 3f 	sts	0x3F0B, r24	; 0x803f0b <alarmTone()::x>
 540:	90 93 0c 3f 	sts	0x3F0C, r25	; 0x803f0c <alarmTone()::x+0x1>
loop():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:60
  }

  // Play Alarm
  if (alarmState) {
    alarmTone();
    digitalWrite(ledPin, HIGH);
 544:	61 e0       	ldi	r22, 0x01	; 1
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:63
  } else {
    noTone(piezoPin);
    digitalWrite(ledPin, LOW);
 546:	84 e0       	ldi	r24, 0x04	; 4
 548:	e1 dd       	rcall	.-1086   	; 0x10c <digitalWrite>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:67
  }

  // Enter sleep mode if conditions are met
  if (!alarmState && digitalRead(buttonPin) == HIGH && millis() - wakeUpMillis >= wakeUpDebounce) {
 54a:	80 91 15 3f 	lds	r24, 0x3F15	; 0x803f15 <alarmState>
 54e:	81 11       	cpse	r24, r1
 550:	24 cf       	rjmp	.-440    	; 0x39a <main+0xa6>
 552:	d6 dd       	rcall	.-1108   	; 0x100 <digitalRead.constprop.0>
 554:	81 30       	cpi	r24, 0x01	; 1
 556:	09 f0       	breq	.+2      	; 0x55a <__LOCK_REGION_LENGTH__+0x15a>
 558:	1e cf       	rjmp	.-452    	; 0x396 <main+0xa2>
 55a:	a3 dd       	rcall	.-1210   	; 0xa2 <millis>
 55c:	c0 90 1b 3f 	lds	r12, 0x3F1B	; 0x803f1b <wakeUpMillis>
 560:	d0 90 1c 3f 	lds	r13, 0x3F1C	; 0x803f1c <wakeUpMillis+0x1>
 564:	e0 90 1d 3f 	lds	r14, 0x3F1D	; 0x803f1d <wakeUpMillis+0x2>
 568:	f0 90 1e 3f 	lds	r15, 0x3F1E	; 0x803f1e <wakeUpMillis+0x3>
 56c:	6c 19       	sub	r22, r12
 56e:	7d 09       	sbc	r23, r13
 570:	8e 09       	sbc	r24, r14
 572:	9f 09       	sbc	r25, r15
 574:	64 36       	cpi	r22, 0x64	; 100
 576:	71 05       	cpc	r23, r1
 578:	81 05       	cpc	r24, r1
 57a:	91 05       	cpc	r25, r1
 57c:	08 f4       	brcc	.+2      	; 0x580 <__LOCK_REGION_LENGTH__+0x180>
 57e:	0b cf       	rjmp	.-490    	; 0x396 <main+0xa2>
enterSleepMode():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:112
    }
  }
}

void enterSleepMode() {
  set_sleep_mode(SLEEP_MODE_PWR_DOWN); // Set the desired sleep mode
 580:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <digital_pin_to_bit_mask+0x7f74ba>
 584:	89 7f       	andi	r24, 0xF9	; 249
 586:	84 60       	ori	r24, 0x04	; 4
 588:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <digital_pin_to_bit_mask+0x7f74ba>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:113
  sleep_enable();                      // Enable sleep mode
 58c:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <digital_pin_to_bit_mask+0x7f74ba>
 590:	81 60       	ori	r24, 0x01	; 1
 592:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <digital_pin_to_bit_mask+0x7f74ba>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:114
  sleep_cpu();                         // Enter sleep mode
 596:	88 95       	sleep
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:117

  // Execution continues here after waking up
  sleep_disable();                     // Disable sleep mode after waking up
 598:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <digital_pin_to_bit_mask+0x7f74ba>
 59c:	8e 7f       	andi	r24, 0xFE	; 254
 59e:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <digital_pin_to_bit_mask+0x7f74ba>
 5a2:	f9 ce       	rjmp	.-526    	; 0x396 <main+0xa2>
tone():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:210
    }
    // Calculate compare value
    int8_t divisionfactor = 0; // no prescale, toggles at twice the frequency

    // Timer settings -- will be type B timer or bust....
    uint32_t compare_val = ((F_CPU / frequency) >> 1);
 5a4:	9b 01       	movw	r18, r22
 5a6:	50 e0       	ldi	r21, 0x00	; 0
 5a8:	40 e0       	ldi	r20, 0x00	; 0
 5aa:	c5 01       	movw	r24, r10
 5ac:	b4 01       	movw	r22, r8
 5ae:	aa d2       	rcall	.+1364   	; 0xb04 <__divmodsi4>
 5b0:	da 01       	movw	r26, r20
 5b2:	c9 01       	movw	r24, r18
 5b4:	b5 95       	asr	r27
 5b6:	a7 95       	ror	r26
 5b8:	97 95       	ror	r25
 5ba:	87 95       	ror	r24
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:213
    // We're are however disabling the timer. There may be one final interrupt at the moment we do so
    // but that's not a problem
    if (compare_val < 0x10000) { /* previously this tested for divisionfactor == 1,
 5bc:	00 97       	sbiw	r24, 0x00	; 0
 5be:	61 e0       	ldi	r22, 0x01	; 1
 5c0:	a6 07       	cpc	r26, r22
 5c2:	b1 05       	cpc	r27, r1
 5c4:	8c f4       	brge	.+34     	; 0x5e8 <__LOCK_REGION_LENGTH__+0x1e8>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:219
      * but that relied on us having already gone through the while loop to
      * adjust it, which we haven't done yet, but we want to do this *after* the
      * timeconsuming division operation, but *before* we actually change any
      * other settings, because this is the point at which we stop the timer -
      * hence it needs to be the first to be set if we want to leave interrupts on*/
      _timer->CTRLA = TCB_CLKSEL_DIV1_gc;
 5c6:	10 92 40 0a 	sts	0x0A40, r1	; 0x800a40 <digital_pin_to_bit_mask+0x7f7eaa>
main():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:207
      // Duration not specified -> infinite
      // Represented internally by toggle_count = -1
      toggle_count = -1;
    }
    // Calculate compare value
    int8_t divisionfactor = 0; // no prescale, toggles at twice the frequency
 5ca:	30 e0       	ldi	r19, 0x00	; 0
tone():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:224
      _timer->CTRLA = TCB_CLKSEL_DIV1_gc;
    } else {
      _timer->CTRLA = TCB_CLKSEL_DIV2_gc;
      divisionfactor--;
    }
    while ((compare_val > 0x10000) && (divisionfactor < 6)) {
 5cc:	81 30       	cpi	r24, 0x01	; 1
 5ce:	91 05       	cpc	r25, r1
 5d0:	21 e0       	ldi	r18, 0x01	; 1
 5d2:	a2 07       	cpc	r26, r18
 5d4:	b1 05       	cpc	r27, r1
 5d6:	68 f0       	brcs	.+26     	; 0x5f2 <__LOCK_REGION_LENGTH__+0x1f2>
 5d8:	36 30       	cpi	r19, 0x06	; 6
 5da:	59 f0       	breq	.+22     	; 0x5f2 <__LOCK_REGION_LENGTH__+0x1f2>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:226
      // If the "else" branch above was followed, this is always true initially.
      compare_val = compare_val >> 1;
 5dc:	b6 95       	lsr	r27
 5de:	a7 95       	ror	r26
 5e0:	97 95       	ror	r25
 5e2:	87 95       	ror	r24
 5e4:	3f 5f       	subi	r19, 0xFF	; 255
 5e6:	f2 cf       	rjmp	.-28     	; 0x5cc <__LOCK_REGION_LENGTH__+0x1cc>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:221
      * timeconsuming division operation, but *before* we actually change any
      * other settings, because this is the point at which we stop the timer -
      * hence it needs to be the first to be set if we want to leave interrupts on*/
      _timer->CTRLA = TCB_CLKSEL_DIV1_gc;
    } else {
      _timer->CTRLA = TCB_CLKSEL_DIV2_gc;
 5e8:	72 e0       	ldi	r23, 0x02	; 2
 5ea:	70 93 40 0a 	sts	0x0A40, r23	; 0x800a40 <digital_pin_to_bit_mask+0x7f7eaa>
main():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:222
      divisionfactor--;
 5ee:	3f ef       	ldi	r19, 0xFF	; 255
 5f0:	ed cf       	rjmp	.-38     	; 0x5cc <__LOCK_REGION_LENGTH__+0x1cc>
 5f2:	01 97       	sbiw	r24, 0x01	; 1
 5f4:	a1 09       	sbc	r26, r1
 5f6:	b1 09       	sbc	r27, r1
 5f8:	00 97       	sbiw	r24, 0x00	; 0
 5fa:	41 e0       	ldi	r20, 0x01	; 1
 5fc:	a4 07       	cpc	r26, r20
 5fe:	b1 05       	cpc	r27, r1
 600:	20 f0       	brcs	.+8      	; 0x60a <__LOCK_REGION_LENGTH__+0x20a>
 602:	8f ef       	ldi	r24, 0xFF	; 255
 604:	9f ef       	ldi	r25, 0xFF	; 255
 606:	a0 e0       	ldi	r26, 0x00	; 0
 608:	b0 e0       	ldi	r27, 0x00	; 0
tone():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:238
      compare_val = 0xFFFF; // do the best we can
    }
    // Serial.println(compare_val);
    // Serial.println(divisionfactor);
    // Anyway - so we know that the new pin is valid....
    if (_pin != pin) {  // ...let's see if we're using it already.
 60a:	20 91 00 3f 	lds	r18, 0x3F00	; 0x803f00 <__DATA_REGION_ORIGIN__>
 60e:	21 30       	cpi	r18, 0x01	; 1
 610:	b1 f0       	breq	.+44     	; 0x63e <__LOCK_REGION_LENGTH__+0x23e>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:239
      if (_pin != NOT_A_PIN) { // If not - were we using one before?
 612:	20 91 00 3f 	lds	r18, 0x3F00	; 0x803f00 <__DATA_REGION_ORIGIN__>
 616:	2f 3f       	cpi	r18, 0xFF	; 255
 618:	41 f0       	breq	.+16     	; 0x62a <__LOCK_REGION_LENGTH__+0x22a>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:245
        // If we were, we're gonna be in a world of hurt if we don't
        // turn it off before we actually start reconfiguring stuff
        // *(timer_outtgl_reg - 5) = timer_bit_mask; // pinMode(_pin, INPUT);    (write dirclr for old pin)
        // Apparently maybe it is intended for the pin to be left as an output?
        // It does need to be LOW though, otherwise it can damage some speakers!
        *(timer_outtgl_reg - 1) = timer_bit_mask; // digitalWrite(_pin, LOW); (write outclr for old pin)
 61a:	e0 91 09 3f 	lds	r30, 0x3F09	; 0x803f09 <timer_outtgl_reg>
 61e:	f0 91 0a 3f 	lds	r31, 0x3F0A	; 0x803f0a <timer_outtgl_reg+0x1>
 622:	20 91 08 3f 	lds	r18, 0x3F08	; 0x803f08 <timer_bit_mask>
 626:	31 97       	sbiw	r30, 0x01	; 1
 628:	20 83       	st	Z, r18
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:249
      }
      // whether or not we _were_ using a pin, we are now, so configure the new one as an output...
      PORT_t *port             = digitalPinToPortStruct(pin);           // Since not known at compile time, use PORTs not VPORTS.
      timer_bit_mask           = bit_mask;                              // We no longer need old pin's bit_mask
 62a:	20 92 08 3f 	sts	0x3F08, r2	; 0x803f08 <timer_bit_mask>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:250
      timer_outtgl_reg         = (volatile uint8_t *) &(port->OUTTGL);  // or toggle register.
 62e:	c0 93 09 3f 	sts	0x3F09, r28	; 0x803f09 <timer_outtgl_reg>
 632:	d0 93 0a 3f 	sts	0x3F0A, r29	; 0x803f0a <timer_outtgl_reg+0x1>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:251
      *(timer_outtgl_reg - 1)  = bit_mask;                              // digitalWrite(pin, LOW);
 636:	20 92 06 04 	sts	0x0406, r2	; 0x800406 <digital_pin_to_bit_mask+0x7f7870>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:252
      *(timer_outtgl_reg - 6)  = bit_mask;                              // pinMode(pin, OUTPUT);
 63a:	20 92 01 04 	sts	0x0401, r2	; 0x800401 <digital_pin_to_bit_mask+0x7f786b>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:255
    }
    // Save the results of our calculations
    timer_toggle_count         = toggle_count;
 63e:	40 92 04 3f 	sts	0x3F04, r4	; 0x803f04 <timer_toggle_count>
 642:	50 92 05 3f 	sts	0x3F05, r5	; 0x803f05 <timer_toggle_count+0x1>
 646:	60 92 06 3f 	sts	0x3F06, r6	; 0x803f06 <timer_toggle_count+0x2>
 64a:	70 92 07 3f 	sts	0x3F07, r7	; 0x803f07 <timer_toggle_count+0x3>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:256
    timer_cycle_per_tgl        = 1 << divisionfactor;     // 1, 2, 4, 8, 16, 32, or 64 - toggle pin once per this many cycles...
 64e:	b8 01       	movw	r22, r16
 650:	02 c0       	rjmp	.+4      	; 0x656 <__LOCK_REGION_LENGTH__+0x256>
 652:	66 0f       	add	r22, r22
 654:	77 1f       	adc	r23, r23
 656:	3a 95       	dec	r19
 658:	e2 f7       	brpl	.-8      	; 0x652 <__LOCK_REGION_LENGTH__+0x252>
 65a:	60 93 03 3f 	sts	0x3F03, r22	; 0x803f03 <timer_cycle_per_tgl>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:257
    timer_cycle_per_tgl_count  = timer_cycle_per_tgl;     // running count of remaining toggle cycles.
 65e:	60 93 02 3f 	sts	0x3F02, r22	; 0x803f02 <__data_end>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:258
    _timer->CCMP               = compare_val;             // ...and each cycle is this many timer ticks long
 662:	80 93 4c 0a 	sts	0x0A4C, r24	; 0x800a4c <digital_pin_to_bit_mask+0x7f7eb6>
 666:	90 93 4d 0a 	sts	0x0A4D, r25	; 0x800a4d <digital_pin_to_bit_mask+0x7f7eb7>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:259
    _timer->CTRLB              = TCB_CNTMODE_INT_gc;      // Set mode to Periodic Interrupt mode.
 66a:	10 92 41 0a 	sts	0x0A41, r1	; 0x800a41 <digital_pin_to_bit_mask+0x7f7eab>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:260
    _timer->CNT                = 0;                       // Not strictly necessary, but ensures there's no glitch.
 66e:	10 92 4a 0a 	sts	0x0A4A, r1	; 0x800a4a <digital_pin_to_bit_mask+0x7f7eb4>
 672:	10 92 4b 0a 	sts	0x0A4B, r1	; 0x800a4b <digital_pin_to_bit_mask+0x7f7eb5>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:261
    _pin                       = pin;                     // Record new pin number.
 676:	30 92 00 3f 	sts	0x3F00, r3	; 0x803f00 <__DATA_REGION_ORIGIN__>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:262
    _timer->INTCTRL            = TCB_CAPTEI_bm;           // Enable the interrupt (flag is already cleared)
 67a:	71 e0       	ldi	r23, 0x01	; 1
 67c:	70 93 45 0a 	sts	0x0A45, r23	; 0x800a45 <digital_pin_to_bit_mask+0x7f7eaf>
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:263
    _timer->CTRLA             |= TCB_ENABLE_bm;           // Everything is ready - Enable timer!
 680:	80 91 40 0a 	lds	r24, 0x0A40	; 0x800a40 <digital_pin_to_bit_mask+0x7f7eaa>
 684:	81 60       	ori	r24, 0x01	; 1
 686:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <digital_pin_to_bit_mask+0x7f7eaa>
 68a:	4e cf       	rjmp	.-356    	; 0x528 <__LOCK_REGION_LENGTH__+0x128>
alarmTone():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:99
      int toneVal = 3950 + (int(sinVal * 200)); // Center at 3950 Hz, amplitude 250 Hz
      tone(piezoPin, toneVal);

      x++;
      if (x >= 360) {
        x = 0;
 68c:	10 92 0b 3f 	sts	0x3F0B, r1	; 0x803f0b <alarmTone()::x>
 690:	10 92 0c 3f 	sts	0x3F0C, r1	; 0x803f0c <alarmTone()::x+0x1>
 694:	57 cf       	rjmp	.-338    	; 0x544 <__LOCK_REGION_LENGTH__+0x144>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:104
      }
    }
  } else {
    // Check if silence period is over
    if (currentMillis - silenceStartMillis >= silenceDuration) {
 696:	84 3f       	cpi	r24, 0xF4	; 244
 698:	91 40       	sbci	r25, 0x01	; 1
 69a:	a1 05       	cpc	r26, r1
 69c:	b1 05       	cpc	r27, r1
 69e:	08 f4       	brcc	.+2      	; 0x6a2 <__LOCK_REGION_LENGTH__+0x2a2>
 6a0:	51 cf       	rjmp	.-350    	; 0x544 <__LOCK_REGION_LENGTH__+0x144>
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:105
      isToneActive = true; // Switch back to tone generation
 6a2:	30 92 01 3f 	sts	0x3F01, r3	; 0x803f01 <alarmTone()::isToneActive>
 6a6:	f9 ce       	rjmp	.-526    	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
noTone():
/Users/carlranieri/Library/Arduino15/packages/megaTinyCore/hardware/megaavr/2.6.10/cores/megatinycore/Tone.cpp:274
#endif

// pin which currently is being used for a tone
#ifndef TONE_UNAVAILABLE
  void noTone(uint8_t pin) {
    if (pin == _pin) {
 6a8:	80 91 00 3f 	lds	r24, 0x3F00	; 0x803f00 <__DATA_REGION_ORIGIN__>
 6ac:	81 30       	cpi	r24, 0x01	; 1
 6ae:	09 f4       	brne	.+2      	; 0x6b2 <__LOCK_REGION_LENGTH__+0x2b2>
 6b0:	15 dd       	rcall	.-1494   	; 0xdc <noTone(unsigned char) [clone .part.0]>
loop():
/Users/carlranieri/Documents/GitHub/SoundDefenseProduction/Firmware/sd-firmware-v2_1/sd-firmware-v2_1.ino:63
  if (alarmState) {
    alarmTone();
    digitalWrite(ledPin, HIGH);
  } else {
    noTone(piezoPin);
    digitalWrite(ledPin, LOW);
 6b2:	60 e0       	ldi	r22, 0x00	; 0
 6b4:	48 cf       	rjmp	.-368    	; 0x546 <__LOCK_REGION_LENGTH__+0x146>

000006b6 <__fixsfsi>:
__fixsfsi():
 6b6:	0e 94 62 03 	call	0x6c4	; 0x6c4 <__fixunssfsi>
 6ba:	68 94       	set
 6bc:	b1 11       	cpse	r27, r1
 6be:	0c 94 f1 03 	jmp	0x7e2	; 0x7e2 <__fp_szero>
 6c2:	08 95       	ret

000006c4 <__fixunssfsi>:
__fixunssfsi():
 6c4:	0e 94 d6 03 	call	0x7ac	; 0x7ac <__fp_splitA>
 6c8:	88 f0       	brcs	.+34     	; 0x6ec <__fixunssfsi+0x28>
 6ca:	9f 57       	subi	r25, 0x7F	; 127
 6cc:	98 f0       	brcs	.+38     	; 0x6f4 <__fixunssfsi+0x30>
 6ce:	b9 2f       	mov	r27, r25
 6d0:	99 27       	eor	r25, r25
 6d2:	b7 51       	subi	r27, 0x17	; 23
 6d4:	b0 f0       	brcs	.+44     	; 0x702 <__fixunssfsi+0x3e>
 6d6:	e1 f0       	breq	.+56     	; 0x710 <__fixunssfsi+0x4c>
 6d8:	66 0f       	add	r22, r22
 6da:	77 1f       	adc	r23, r23
 6dc:	88 1f       	adc	r24, r24
 6de:	99 1f       	adc	r25, r25
 6e0:	1a f0       	brmi	.+6      	; 0x6e8 <__fixunssfsi+0x24>
 6e2:	ba 95       	dec	r27
 6e4:	c9 f7       	brne	.-14     	; 0x6d8 <__fixunssfsi+0x14>
 6e6:	14 c0       	rjmp	.+40     	; 0x710 <__fixunssfsi+0x4c>
 6e8:	b1 30       	cpi	r27, 0x01	; 1
 6ea:	91 f0       	breq	.+36     	; 0x710 <__fixunssfsi+0x4c>
 6ec:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <__fp_zero>
 6f0:	b1 e0       	ldi	r27, 0x01	; 1
 6f2:	08 95       	ret
 6f4:	0c 94 f0 03 	jmp	0x7e0	; 0x7e0 <__fp_zero>
 6f8:	67 2f       	mov	r22, r23
 6fa:	78 2f       	mov	r23, r24
 6fc:	88 27       	eor	r24, r24
 6fe:	b8 5f       	subi	r27, 0xF8	; 248
 700:	39 f0       	breq	.+14     	; 0x710 <__fixunssfsi+0x4c>
 702:	b9 3f       	cpi	r27, 0xF9	; 249
 704:	cc f3       	brlt	.-14     	; 0x6f8 <__fixunssfsi+0x34>
 706:	86 95       	lsr	r24
 708:	77 95       	ror	r23
 70a:	67 95       	ror	r22
 70c:	b3 95       	inc	r27
 70e:	d9 f7       	brne	.-10     	; 0x706 <__fixunssfsi+0x42>
 710:	3e f4       	brtc	.+14     	; 0x720 <__fixunssfsi+0x5c>
 712:	90 95       	com	r25
 714:	80 95       	com	r24
 716:	70 95       	com	r23
 718:	61 95       	neg	r22
 71a:	7f 4f       	sbci	r23, 0xFF	; 255
 71c:	8f 4f       	sbci	r24, 0xFF	; 255
 71e:	9f 4f       	sbci	r25, 0xFF	; 255
 720:	08 95       	ret

00000722 <__floatunsisf>:
__floatunsisf():
 722:	e8 94       	clt
 724:	09 c0       	rjmp	.+18     	; 0x738 <__floatsisf+0x12>

00000726 <__floatsisf>:
 726:	97 fb       	bst	r25, 7
 728:	3e f4       	brtc	.+14     	; 0x738 <__floatsisf+0x12>
 72a:	90 95       	com	r25
 72c:	80 95       	com	r24
 72e:	70 95       	com	r23
 730:	61 95       	neg	r22
 732:	7f 4f       	sbci	r23, 0xFF	; 255
 734:	8f 4f       	sbci	r24, 0xFF	; 255
 736:	9f 4f       	sbci	r25, 0xFF	; 255
 738:	99 23       	and	r25, r25
 73a:	a9 f0       	breq	.+42     	; 0x766 <__floatsisf+0x40>
 73c:	f9 2f       	mov	r31, r25
 73e:	96 e9       	ldi	r25, 0x96	; 150
 740:	bb 27       	eor	r27, r27
 742:	93 95       	inc	r25
 744:	f6 95       	lsr	r31
 746:	87 95       	ror	r24
 748:	77 95       	ror	r23
 74a:	67 95       	ror	r22
 74c:	b7 95       	ror	r27
 74e:	f1 11       	cpse	r31, r1
 750:	f8 cf       	rjmp	.-16     	; 0x742 <__floatsisf+0x1c>
 752:	fa f4       	brpl	.+62     	; 0x792 <__floatsisf+0x6c>
 754:	bb 0f       	add	r27, r27
 756:	11 f4       	brne	.+4      	; 0x75c <__floatsisf+0x36>
 758:	60 ff       	sbrs	r22, 0
 75a:	1b c0       	rjmp	.+54     	; 0x792 <__floatsisf+0x6c>
 75c:	6f 5f       	subi	r22, 0xFF	; 255
 75e:	7f 4f       	sbci	r23, 0xFF	; 255
 760:	8f 4f       	sbci	r24, 0xFF	; 255
 762:	9f 4f       	sbci	r25, 0xFF	; 255
 764:	16 c0       	rjmp	.+44     	; 0x792 <__floatsisf+0x6c>
 766:	88 23       	and	r24, r24
 768:	11 f0       	breq	.+4      	; 0x76e <__floatsisf+0x48>
 76a:	96 e9       	ldi	r25, 0x96	; 150
 76c:	11 c0       	rjmp	.+34     	; 0x790 <__floatsisf+0x6a>
 76e:	77 23       	and	r23, r23
 770:	21 f0       	breq	.+8      	; 0x77a <__floatsisf+0x54>
 772:	9e e8       	ldi	r25, 0x8E	; 142
 774:	87 2f       	mov	r24, r23
 776:	76 2f       	mov	r23, r22
 778:	05 c0       	rjmp	.+10     	; 0x784 <__floatsisf+0x5e>
 77a:	66 23       	and	r22, r22
 77c:	71 f0       	breq	.+28     	; 0x79a <__floatsisf+0x74>
 77e:	96 e8       	ldi	r25, 0x86	; 134
 780:	86 2f       	mov	r24, r22
 782:	70 e0       	ldi	r23, 0x00	; 0
 784:	60 e0       	ldi	r22, 0x00	; 0
 786:	2a f0       	brmi	.+10     	; 0x792 <__floatsisf+0x6c>
 788:	9a 95       	dec	r25
 78a:	66 0f       	add	r22, r22
 78c:	77 1f       	adc	r23, r23
 78e:	88 1f       	adc	r24, r24
 790:	da f7       	brpl	.-10     	; 0x788 <__floatsisf+0x62>
 792:	88 0f       	add	r24, r24
 794:	96 95       	lsr	r25
 796:	87 95       	ror	r24
 798:	97 f9       	bld	r25, 7
 79a:	08 95       	ret

0000079c <__fp_split3>:
__fp_split3():
 79c:	57 fd       	sbrc	r21, 7
 79e:	90 58       	subi	r25, 0x80	; 128
 7a0:	44 0f       	add	r20, r20
 7a2:	55 1f       	adc	r21, r21
 7a4:	59 f0       	breq	.+22     	; 0x7bc <__fp_splitA+0x10>
 7a6:	5f 3f       	cpi	r21, 0xFF	; 255
 7a8:	71 f0       	breq	.+28     	; 0x7c6 <__fp_splitA+0x1a>
 7aa:	47 95       	ror	r20

000007ac <__fp_splitA>:
 7ac:	88 0f       	add	r24, r24
 7ae:	97 fb       	bst	r25, 7
 7b0:	99 1f       	adc	r25, r25
 7b2:	61 f0       	breq	.+24     	; 0x7cc <__fp_splitA+0x20>
 7b4:	9f 3f       	cpi	r25, 0xFF	; 255
 7b6:	79 f0       	breq	.+30     	; 0x7d6 <__fp_splitA+0x2a>
 7b8:	87 95       	ror	r24
 7ba:	08 95       	ret
 7bc:	12 16       	cp	r1, r18
 7be:	13 06       	cpc	r1, r19
 7c0:	14 06       	cpc	r1, r20
 7c2:	55 1f       	adc	r21, r21
 7c4:	f2 cf       	rjmp	.-28     	; 0x7aa <__fp_split3+0xe>
 7c6:	46 95       	lsr	r20
 7c8:	f1 df       	rcall	.-30     	; 0x7ac <__fp_splitA>
 7ca:	08 c0       	rjmp	.+16     	; 0x7dc <__fp_splitA+0x30>
 7cc:	16 16       	cp	r1, r22
 7ce:	17 06       	cpc	r1, r23
 7d0:	18 06       	cpc	r1, r24
 7d2:	99 1f       	adc	r25, r25
 7d4:	f1 cf       	rjmp	.-30     	; 0x7b8 <__fp_splitA+0xc>
 7d6:	86 95       	lsr	r24
 7d8:	71 05       	cpc	r23, r1
 7da:	61 05       	cpc	r22, r1
 7dc:	08 94       	sec
 7de:	08 95       	ret

000007e0 <__fp_zero>:
__fp_zero():
 7e0:	e8 94       	clt

000007e2 <__fp_szero>:
 7e2:	bb 27       	eor	r27, r27
 7e4:	66 27       	eor	r22, r22
 7e6:	77 27       	eor	r23, r23
 7e8:	cb 01       	movw	r24, r22
 7ea:	97 f9       	bld	r25, 7
 7ec:	08 95       	ret

000007ee <__mulsf3>:
__mulsf3():
 7ee:	0e 94 0a 04 	call	0x814	; 0x814 <__mulsf3x>
 7f2:	0c 94 ae 04 	jmp	0x95c	; 0x95c <__fp_round>
 7f6:	0e 94 75 04 	call	0x8ea	; 0x8ea <__fp_pscA>
 7fa:	38 f0       	brcs	.+14     	; 0x80a <__mulsf3+0x1c>
 7fc:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <__fp_pscB>
 800:	20 f0       	brcs	.+8      	; 0x80a <__mulsf3+0x1c>
 802:	95 23       	and	r25, r21
 804:	11 f0       	breq	.+4      	; 0x80a <__mulsf3+0x1c>
 806:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__fp_inf>
 80a:	0c 94 72 04 	jmp	0x8e4	; 0x8e4 <__fp_nan>
 80e:	11 24       	eor	r1, r1
 810:	0c 94 f1 03 	jmp	0x7e2	; 0x7e2 <__fp_szero>

00000814 <__mulsf3x>:
__mulsf3x():
 814:	0e 94 ce 03 	call	0x79c	; 0x79c <__fp_split3>
 818:	70 f3       	brcs	.-36     	; 0x7f6 <__mulsf3+0x8>

0000081a <__mulsf3_pse>:
 81a:	95 9f       	mul	r25, r21
 81c:	c1 f3       	breq	.-16     	; 0x80e <__mulsf3+0x20>
 81e:	95 0f       	add	r25, r21
 820:	50 e0       	ldi	r21, 0x00	; 0
 822:	55 1f       	adc	r21, r21
 824:	62 9f       	mul	r22, r18
 826:	f0 01       	movw	r30, r0
 828:	72 9f       	mul	r23, r18
 82a:	bb 27       	eor	r27, r27
 82c:	f0 0d       	add	r31, r0
 82e:	b1 1d       	adc	r27, r1
 830:	63 9f       	mul	r22, r19
 832:	aa 27       	eor	r26, r26
 834:	f0 0d       	add	r31, r0
 836:	b1 1d       	adc	r27, r1
 838:	aa 1f       	adc	r26, r26
 83a:	64 9f       	mul	r22, r20
 83c:	66 27       	eor	r22, r22
 83e:	b0 0d       	add	r27, r0
 840:	a1 1d       	adc	r26, r1
 842:	66 1f       	adc	r22, r22
 844:	82 9f       	mul	r24, r18
 846:	22 27       	eor	r18, r18
 848:	b0 0d       	add	r27, r0
 84a:	a1 1d       	adc	r26, r1
 84c:	62 1f       	adc	r22, r18
 84e:	73 9f       	mul	r23, r19
 850:	b0 0d       	add	r27, r0
 852:	a1 1d       	adc	r26, r1
 854:	62 1f       	adc	r22, r18
 856:	83 9f       	mul	r24, r19
 858:	a0 0d       	add	r26, r0
 85a:	61 1d       	adc	r22, r1
 85c:	22 1f       	adc	r18, r18
 85e:	74 9f       	mul	r23, r20
 860:	33 27       	eor	r19, r19
 862:	a0 0d       	add	r26, r0
 864:	61 1d       	adc	r22, r1
 866:	23 1f       	adc	r18, r19
 868:	84 9f       	mul	r24, r20
 86a:	60 0d       	add	r22, r0
 86c:	21 1d       	adc	r18, r1
 86e:	82 2f       	mov	r24, r18
 870:	76 2f       	mov	r23, r22
 872:	6a 2f       	mov	r22, r26
 874:	11 24       	eor	r1, r1
 876:	9f 57       	subi	r25, 0x7F	; 127
 878:	50 40       	sbci	r21, 0x00	; 0
 87a:	9a f0       	brmi	.+38     	; 0x8a2 <__mulsf3_pse+0x88>
 87c:	f1 f0       	breq	.+60     	; 0x8ba <__mulsf3_pse+0xa0>
 87e:	88 23       	and	r24, r24
 880:	4a f0       	brmi	.+18     	; 0x894 <__mulsf3_pse+0x7a>
 882:	ee 0f       	add	r30, r30
 884:	ff 1f       	adc	r31, r31
 886:	bb 1f       	adc	r27, r27
 888:	66 1f       	adc	r22, r22
 88a:	77 1f       	adc	r23, r23
 88c:	88 1f       	adc	r24, r24
 88e:	91 50       	subi	r25, 0x01	; 1
 890:	50 40       	sbci	r21, 0x00	; 0
 892:	a9 f7       	brne	.-22     	; 0x87e <__mulsf3_pse+0x64>
 894:	9e 3f       	cpi	r25, 0xFE	; 254
 896:	51 05       	cpc	r21, r1
 898:	80 f0       	brcs	.+32     	; 0x8ba <__mulsf3_pse+0xa0>
 89a:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__fp_inf>
 89e:	0c 94 f1 03 	jmp	0x7e2	; 0x7e2 <__fp_szero>
 8a2:	5f 3f       	cpi	r21, 0xFF	; 255
 8a4:	e4 f3       	brlt	.-8      	; 0x89e <__mulsf3_pse+0x84>
 8a6:	98 3e       	cpi	r25, 0xE8	; 232
 8a8:	d4 f3       	brlt	.-12     	; 0x89e <__mulsf3_pse+0x84>
 8aa:	86 95       	lsr	r24
 8ac:	77 95       	ror	r23
 8ae:	67 95       	ror	r22
 8b0:	b7 95       	ror	r27
 8b2:	f7 95       	ror	r31
 8b4:	e7 95       	ror	r30
 8b6:	9f 5f       	subi	r25, 0xFF	; 255
 8b8:	c1 f7       	brne	.-16     	; 0x8aa <__mulsf3_pse+0x90>
 8ba:	fe 2b       	or	r31, r30
 8bc:	88 0f       	add	r24, r24
 8be:	91 1d       	adc	r25, r1
 8c0:	96 95       	lsr	r25
 8c2:	87 95       	ror	r24
 8c4:	97 f9       	bld	r25, 7
 8c6:	08 95       	ret

000008c8 <sin>:
 8c8:	9f 93       	push	r25
 8ca:	0e 94 85 04 	call	0x90a	; 0x90a <__fp_rempio2>
 8ce:	0f 90       	pop	r0
 8d0:	07 fc       	sbrc	r0, 7
 8d2:	ee 5f       	subi	r30, 0xFE	; 254
 8d4:	0c 94 bf 04 	jmp	0x97e	; 0x97e <__fp_sinus>

000008d8 <__fp_inf>:
 8d8:	97 f9       	bld	r25, 7
 8da:	9f 67       	ori	r25, 0x7F	; 127
 8dc:	80 e8       	ldi	r24, 0x80	; 128
 8de:	70 e0       	ldi	r23, 0x00	; 0
 8e0:	60 e0       	ldi	r22, 0x00	; 0
 8e2:	08 95       	ret

000008e4 <__fp_nan>:
 8e4:	9f ef       	ldi	r25, 0xFF	; 255
__fp_nan():
 8e6:	80 ec       	ldi	r24, 0xC0	; 192
 8e8:	08 95       	ret

000008ea <__fp_pscA>:
__fp_pscA():
 8ea:	00 24       	eor	r0, r0
 8ec:	0a 94       	dec	r0
 8ee:	16 16       	cp	r1, r22
 8f0:	17 06       	cpc	r1, r23
 8f2:	18 06       	cpc	r1, r24
 8f4:	09 06       	cpc	r0, r25
 8f6:	08 95       	ret

000008f8 <__fp_pscB>:
__fp_pscB():
 8f8:	00 24       	eor	r0, r0
 8fa:	0a 94       	dec	r0
 8fc:	12 16       	cp	r1, r18
 8fe:	13 06       	cpc	r1, r19
 900:	14 06       	cpc	r1, r20
 902:	05 06       	cpc	r0, r21
 904:	08 95       	ret
 906:	0c 94 72 04 	jmp	0x8e4	; 0x8e4 <__fp_nan>

0000090a <__fp_rempio2>:
__fp_rempio2():
 90a:	0e 94 d6 03 	call	0x7ac	; 0x7ac <__fp_splitA>
 90e:	d8 f3       	brcs	.-10     	; 0x906 <__fp_pscB+0xe>
 910:	e8 94       	clt
 912:	e0 e0       	ldi	r30, 0x00	; 0
 914:	bb 27       	eor	r27, r27
 916:	9f 57       	subi	r25, 0x7F	; 127
 918:	f0 f0       	brcs	.+60     	; 0x956 <__fp_rempio2+0x4c>
 91a:	2a ed       	ldi	r18, 0xDA	; 218
 91c:	3f e0       	ldi	r19, 0x0F	; 15
 91e:	49 ec       	ldi	r20, 0xC9	; 201
 920:	06 c0       	rjmp	.+12     	; 0x92e <__fp_rempio2+0x24>
 922:	ee 0f       	add	r30, r30
 924:	bb 0f       	add	r27, r27
 926:	66 1f       	adc	r22, r22
 928:	77 1f       	adc	r23, r23
 92a:	88 1f       	adc	r24, r24
 92c:	28 f0       	brcs	.+10     	; 0x938 <__fp_rempio2+0x2e>
 92e:	b2 3a       	cpi	r27, 0xA2	; 162
 930:	62 07       	cpc	r22, r18
 932:	73 07       	cpc	r23, r19
 934:	84 07       	cpc	r24, r20
 936:	28 f0       	brcs	.+10     	; 0x942 <__fp_rempio2+0x38>
 938:	b2 5a       	subi	r27, 0xA2	; 162
 93a:	62 0b       	sbc	r22, r18
 93c:	73 0b       	sbc	r23, r19
 93e:	84 0b       	sbc	r24, r20
 940:	e3 95       	inc	r30
 942:	9a 95       	dec	r25
 944:	72 f7       	brpl	.-36     	; 0x922 <__fp_rempio2+0x18>
 946:	80 38       	cpi	r24, 0x80	; 128
 948:	30 f4       	brcc	.+12     	; 0x956 <__fp_rempio2+0x4c>
 94a:	9a 95       	dec	r25
 94c:	bb 0f       	add	r27, r27
 94e:	66 1f       	adc	r22, r22
 950:	77 1f       	adc	r23, r23
 952:	88 1f       	adc	r24, r24
 954:	d2 f7       	brpl	.-12     	; 0x94a <__fp_rempio2+0x40>
 956:	90 48       	sbci	r25, 0x80	; 128
 958:	0c 94 3b 05 	jmp	0xa76	; 0xa76 <__fp_mpack_finite>

0000095c <__fp_round>:
 95c:	09 2e       	mov	r0, r25
 95e:	03 94       	inc	r0
__fp_round():
 960:	00 0c       	add	r0, r0
 962:	11 f4       	brne	.+4      	; 0x968 <__fp_round+0xc>
 964:	88 23       	and	r24, r24
 966:	52 f0       	brmi	.+20     	; 0x97c <__fp_round+0x20>
 968:	bb 0f       	add	r27, r27
 96a:	40 f4       	brcc	.+16     	; 0x97c <__fp_round+0x20>
 96c:	bf 2b       	or	r27, r31
 96e:	11 f4       	brne	.+4      	; 0x974 <__fp_round+0x18>
 970:	60 ff       	sbrs	r22, 0
 972:	04 c0       	rjmp	.+8      	; 0x97c <__fp_round+0x20>
 974:	6f 5f       	subi	r22, 0xFF	; 255
 976:	7f 4f       	sbci	r23, 0xFF	; 255
 978:	8f 4f       	sbci	r24, 0xFF	; 255
 97a:	9f 4f       	sbci	r25, 0xFF	; 255
 97c:	08 95       	ret

0000097e <__fp_sinus>:
__fp_sinus():
 97e:	ef 93       	push	r30
 980:	e0 ff       	sbrs	r30, 0
 982:	07 c0       	rjmp	.+14     	; 0x992 <__fp_sinus+0x14>
 984:	a2 ea       	ldi	r26, 0xA2	; 162
 986:	2a ed       	ldi	r18, 0xDA	; 218
 988:	3f e0       	ldi	r19, 0x0F	; 15
 98a:	49 ec       	ldi	r20, 0xC9	; 201
 98c:	5f eb       	ldi	r21, 0xBF	; 191
 98e:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <__addsf3x>
 992:	0e 94 ae 04 	call	0x95c	; 0x95c <__fp_round>
 996:	0f 90       	pop	r0
 998:	03 94       	inc	r0
 99a:	01 fc       	sbrc	r0, 1
 99c:	90 58       	subi	r25, 0x80	; 128
 99e:	e4 e3       	ldi	r30, 0x34	; 52
 9a0:	f0 e0       	ldi	r31, 0x00	; 0
 9a2:	0c 94 47 05 	jmp	0xa8e	; 0xa8e <__fp_powsodd>
 9a6:	0e 94 75 04 	call	0x8ea	; 0x8ea <__fp_pscA>
 9aa:	38 f0       	brcs	.+14     	; 0x9ba <__fp_sinus+0x3c>
 9ac:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <__fp_pscB>
 9b0:	20 f0       	brcs	.+8      	; 0x9ba <__fp_sinus+0x3c>
 9b2:	39 f4       	brne	.+14     	; 0x9c2 <__fp_sinus+0x44>
 9b4:	9f 3f       	cpi	r25, 0xFF	; 255
 9b6:	19 f4       	brne	.+6      	; 0x9be <__fp_sinus+0x40>
 9b8:	26 f4       	brtc	.+8      	; 0x9c2 <__fp_sinus+0x44>
 9ba:	0c 94 72 04 	jmp	0x8e4	; 0x8e4 <__fp_nan>
 9be:	0e f4       	brtc	.+2      	; 0x9c2 <__fp_sinus+0x44>
 9c0:	e0 95       	com	r30
 9c2:	e7 fb       	bst	r30, 7
 9c4:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__fp_inf>

000009c8 <__addsf3x>:
__addsf3x():
 9c8:	e9 2f       	mov	r30, r25
 9ca:	0e 94 ce 03 	call	0x79c	; 0x79c <__fp_split3>
 9ce:	58 f3       	brcs	.-42     	; 0x9a6 <__fp_sinus+0x28>
 9d0:	ba 17       	cp	r27, r26
 9d2:	62 07       	cpc	r22, r18
 9d4:	73 07       	cpc	r23, r19
 9d6:	84 07       	cpc	r24, r20
 9d8:	95 07       	cpc	r25, r21
 9da:	20 f0       	brcs	.+8      	; 0x9e4 <__addsf3x+0x1c>
 9dc:	79 f4       	brne	.+30     	; 0x9fc <__addsf3x+0x34>
 9de:	a6 f5       	brtc	.+104    	; 0xa48 <__addsf3x+0x80>
 9e0:	0c 94 f0 03 	jmp	0x7e0	; 0x7e0 <__fp_zero>
 9e4:	0e f4       	brtc	.+2      	; 0x9e8 <__addsf3x+0x20>
 9e6:	e0 95       	com	r30
 9e8:	0b 2e       	mov	r0, r27
 9ea:	ba 2f       	mov	r27, r26
 9ec:	a0 2d       	mov	r26, r0
 9ee:	0b 01       	movw	r0, r22
 9f0:	b9 01       	movw	r22, r18
 9f2:	90 01       	movw	r18, r0
 9f4:	0c 01       	movw	r0, r24
 9f6:	ca 01       	movw	r24, r20
 9f8:	a0 01       	movw	r20, r0
 9fa:	11 24       	eor	r1, r1
 9fc:	ff 27       	eor	r31, r31
 9fe:	59 1b       	sub	r21, r25
 a00:	99 f0       	breq	.+38     	; 0xa28 <__addsf3x+0x60>
 a02:	59 3f       	cpi	r21, 0xF9	; 249
 a04:	50 f4       	brcc	.+20     	; 0xa1a <__addsf3x+0x52>
 a06:	50 3e       	cpi	r21, 0xE0	; 224
 a08:	68 f1       	brcs	.+90     	; 0xa64 <__addsf3x+0x9c>
 a0a:	1a 16       	cp	r1, r26
 a0c:	f0 40       	sbci	r31, 0x00	; 0
 a0e:	a2 2f       	mov	r26, r18
 a10:	23 2f       	mov	r18, r19
 a12:	34 2f       	mov	r19, r20
 a14:	44 27       	eor	r20, r20
 a16:	58 5f       	subi	r21, 0xF8	; 248
 a18:	f3 cf       	rjmp	.-26     	; 0xa00 <__addsf3x+0x38>
 a1a:	46 95       	lsr	r20
 a1c:	37 95       	ror	r19
 a1e:	27 95       	ror	r18
 a20:	a7 95       	ror	r26
 a22:	f0 40       	sbci	r31, 0x00	; 0
 a24:	53 95       	inc	r21
 a26:	c9 f7       	brne	.-14     	; 0xa1a <__addsf3x+0x52>
 a28:	7e f4       	brtc	.+30     	; 0xa48 <__addsf3x+0x80>
 a2a:	1f 16       	cp	r1, r31
 a2c:	ba 0b       	sbc	r27, r26
 a2e:	62 0b       	sbc	r22, r18
 a30:	73 0b       	sbc	r23, r19
 a32:	84 0b       	sbc	r24, r20
 a34:	ba f0       	brmi	.+46     	; 0xa64 <__addsf3x+0x9c>
 a36:	91 50       	subi	r25, 0x01	; 1
 a38:	a1 f0       	breq	.+40     	; 0xa62 <__addsf3x+0x9a>
 a3a:	ff 0f       	add	r31, r31
 a3c:	bb 1f       	adc	r27, r27
 a3e:	66 1f       	adc	r22, r22
 a40:	77 1f       	adc	r23, r23
 a42:	88 1f       	adc	r24, r24
 a44:	c2 f7       	brpl	.-16     	; 0xa36 <__addsf3x+0x6e>
 a46:	0e c0       	rjmp	.+28     	; 0xa64 <__addsf3x+0x9c>
 a48:	ba 0f       	add	r27, r26
 a4a:	62 1f       	adc	r22, r18
 a4c:	73 1f       	adc	r23, r19
 a4e:	84 1f       	adc	r24, r20
 a50:	48 f4       	brcc	.+18     	; 0xa64 <__addsf3x+0x9c>
 a52:	87 95       	ror	r24
 a54:	77 95       	ror	r23
 a56:	67 95       	ror	r22
 a58:	b7 95       	ror	r27
 a5a:	f7 95       	ror	r31
 a5c:	9e 3f       	cpi	r25, 0xFE	; 254
 a5e:	08 f0       	brcs	.+2      	; 0xa62 <__addsf3x+0x9a>
 a60:	b0 cf       	rjmp	.-160    	; 0x9c2 <__fp_sinus+0x44>
 a62:	93 95       	inc	r25
 a64:	88 0f       	add	r24, r24
 a66:	08 f0       	brcs	.+2      	; 0xa6a <__addsf3x+0xa2>
 a68:	99 27       	eor	r25, r25
 a6a:	ee 0f       	add	r30, r30
 a6c:	97 95       	ror	r25
 a6e:	87 95       	ror	r24
 a70:	08 95       	ret

00000a72 <__fp_mpack>:
 a72:	9f 3f       	cpi	r25, 0xFF	; 255
 a74:	31 f0       	breq	.+12     	; 0xa82 <__fp_mpack_finite+0xc>

00000a76 <__fp_mpack_finite>:
 a76:	91 50       	subi	r25, 0x01	; 1
 a78:	20 f4       	brcc	.+8      	; 0xa82 <__fp_mpack_finite+0xc>
 a7a:	87 95       	ror	r24
 a7c:	77 95       	ror	r23
 a7e:	67 95       	ror	r22
 a80:	b7 95       	ror	r27
 a82:	88 0f       	add	r24, r24
 a84:	91 1d       	adc	r25, r1
 a86:	96 95       	lsr	r25
 a88:	87 95       	ror	r24
 a8a:	97 f9       	bld	r25, 7
 a8c:	08 95       	ret

00000a8e <__fp_powsodd>:
 a8e:	9f 93       	push	r25
 a90:	8f 93       	push	r24
 a92:	7f 93       	push	r23
__fp_powsodd():
 a94:	6f 93       	push	r22
 a96:	ff 93       	push	r31
 a98:	ef 93       	push	r30
 a9a:	9b 01       	movw	r18, r22
 a9c:	ac 01       	movw	r20, r24
 a9e:	0e 94 f7 03 	call	0x7ee	; 0x7ee <__mulsf3>
 aa2:	ef 91       	pop	r30
 aa4:	ff 91       	pop	r31
 aa6:	0e 94 5b 05 	call	0xab6	; 0xab6 <__fp_powser>
 aaa:	2f 91       	pop	r18
 aac:	3f 91       	pop	r19
 aae:	4f 91       	pop	r20
 ab0:	5f 91       	pop	r21
 ab2:	0c 94 f7 03 	jmp	0x7ee	; 0x7ee <__mulsf3>

00000ab6 <__fp_powser>:
__fp_powser():
 ab6:	df 93       	push	r29
 ab8:	cf 93       	push	r28
 aba:	1f 93       	push	r17
 abc:	0f 93       	push	r16
 abe:	ff 92       	push	r15
 ac0:	ef 92       	push	r14
 ac2:	df 92       	push	r13
 ac4:	7b 01       	movw	r14, r22
 ac6:	8c 01       	movw	r16, r24
 ac8:	68 94       	set
 aca:	06 c0       	rjmp	.+12     	; 0xad8 <__fp_powser+0x22>
 acc:	da 2e       	mov	r13, r26
 ace:	ef 01       	movw	r28, r30
 ad0:	0e 94 0a 04 	call	0x814	; 0x814 <__mulsf3x>
 ad4:	fe 01       	movw	r30, r28
 ad6:	e8 94       	clt
 ad8:	a5 91       	lpm	r26, Z+
 ada:	25 91       	lpm	r18, Z+
 adc:	35 91       	lpm	r19, Z+
 ade:	45 91       	lpm	r20, Z+
 ae0:	55 91       	lpm	r21, Z+
 ae2:	a6 f3       	brts	.-24     	; 0xacc <__fp_powser+0x16>
 ae4:	ef 01       	movw	r28, r30
 ae6:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <__addsf3x>
 aea:	fe 01       	movw	r30, r28
 aec:	97 01       	movw	r18, r14
 aee:	a8 01       	movw	r20, r16
 af0:	da 94       	dec	r13
 af2:	69 f7       	brne	.-38     	; 0xace <__fp_powser+0x18>
 af4:	df 90       	pop	r13
 af6:	ef 90       	pop	r14
 af8:	ff 90       	pop	r15
 afa:	0f 91       	pop	r16
 afc:	1f 91       	pop	r17
 afe:	cf 91       	pop	r28
 b00:	df 91       	pop	r29
 b02:	08 95       	ret

00000b04 <__divmodsi4>:
__divmodsi4():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
 b04:	05 2e       	mov	r0, r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
 b06:	97 fb       	bst	r25, 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
 b08:	16 f4       	brtc	.+4      	; 0xb0e <__divmodsi4+0xa>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
 b0a:	00 94       	com	r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
 b0c:	0f d0       	rcall	.+30     	; 0xb2c <__negsi2>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
 b0e:	57 fd       	sbrc	r21, 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1693
 b10:	05 d0       	rcall	.+10     	; 0xb1c <__divmodsi4_neg2>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
 b12:	14 d0       	rcall	.+40     	; 0xb3c <__udivmodsi4>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
 b14:	07 fc       	sbrc	r0, 7
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1696
 b16:	02 d0       	rcall	.+4      	; 0xb1c <__divmodsi4_neg2>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
 b18:	46 f4       	brtc	.+16     	; 0xb2a <__divmodsi4_exit>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
 b1a:	08 c0       	rjmp	.+16     	; 0xb2c <__negsi2>

00000b1c <__divmodsi4_neg2>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
 b1c:	50 95       	com	r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
 b1e:	40 95       	com	r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
 b20:	30 95       	com	r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
 b22:	21 95       	neg	r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
 b24:	3f 4f       	sbci	r19, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
 b26:	4f 4f       	sbci	r20, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
 b28:	5f 4f       	sbci	r21, 0xFF	; 255

00000b2a <__divmodsi4_exit>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
 b2a:	08 95       	ret

00000b2c <__negsi2>:
__negsi2():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
 b2c:	90 95       	com	r25
 b2e:	80 95       	com	r24
 b30:	70 95       	com	r23
 b32:	61 95       	neg	r22
 b34:	7f 4f       	sbci	r23, 0xFF	; 255
 b36:	8f 4f       	sbci	r24, 0xFF	; 255
 b38:	9f 4f       	sbci	r25, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
 b3a:	08 95       	ret

00000b3c <__udivmodsi4>:
__udivmodsi4():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
 b3c:	a1 e2       	ldi	r26, 0x21	; 33
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
 b3e:	1a 2e       	mov	r1, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
 b40:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
 b42:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
 b44:	fd 01       	movw	r30, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
 b46:	0d c0       	rjmp	.+26     	; 0xb62 <__udivmodsi4_ep>

00000b48 <__udivmodsi4_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
 b48:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
 b4a:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
 b4c:	ee 1f       	adc	r30, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
 b4e:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
 b50:	a2 17       	cp	r26, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
 b52:	b3 07       	cpc	r27, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
 b54:	e4 07       	cpc	r30, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
 b56:	f5 07       	cpc	r31, r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
 b58:	20 f0       	brcs	.+8      	; 0xb62 <__udivmodsi4_ep>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
 b5a:	a2 1b       	sub	r26, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
 b5c:	b3 0b       	sbc	r27, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
 b5e:	e4 0b       	sbc	r30, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
 b60:	f5 0b       	sbc	r31, r21

00000b62 <__udivmodsi4_ep>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
 b62:	66 1f       	adc	r22, r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
 b64:	77 1f       	adc	r23, r23
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
 b66:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
 b68:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
 b6a:	1a 94       	dec	r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
 b6c:	69 f7       	brne	.-38     	; 0xb48 <__udivmodsi4_loop>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
 b6e:	60 95       	com	r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
 b70:	70 95       	com	r23
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
 b72:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
 b74:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
 b76:	9b 01       	movw	r18, r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
 b78:	ac 01       	movw	r20, r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
 b7a:	bd 01       	movw	r22, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
 b7c:	cf 01       	movw	r24, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
 b7e:	08 95       	ret

00000b80 <_exit>:
exit():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 b80:	f8 94       	cli

00000b82 <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 b82:	ff cf       	rjmp	.-2      	; 0xb82 <__stop_program>
